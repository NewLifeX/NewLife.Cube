# 第38章 前端对接指南

> 本章介绍各类前端框架如何对接魔方 WebAPI，包括 Vue、Antd、Blazor 等前端项目。

---

## 38.1 Vue 版前端

### NewLife.CubeVue

官方 Vue 版前端项目，基于 Vue 3 + Element Plus：

**项目地址**：https://github.com/NewLifeX/NewLife.CubeVue

### 安装使用

```bash
# 克隆项目
git clone https://github.com/NewLifeX/NewLife.CubeVue.git

# 安装依赖
cd NewLife.CubeVue
npm install

# 配置后端地址
# 修改 .env.development
VITE_API_URL=http://localhost:5000

# 启动开发服务器
npm run dev
```

### 核心功能

- 动态菜单
- 字段元数据驱动表单
- 通用 CRUD 组件
- 权限控制

### NewLife.QuickVue

快速开发版 Vue 前端：

**项目地址**：https://github.com/NewLifeX/NewLife.QuickVue

---

## 38.2 Antd 版前端

### NewLife.CubeAntd

基于 React + Ant Design 的前端项目：

**项目地址**：https://github.com/NewLifeX/NewLife.CubeAntd

### 特点

- React 18
- Ant Design 5.x
- ProComponents
- TypeScript

---

## 38.3 Blazor 版前端

### NewLife.CubeBlazor

基于 Blazor 的前端项目：

**项目地址**：https://github.com/NewLifeX/NewLife.CubeBlazor

### 特点

- Blazor WebAssembly
- Bootstrap Blazor 组件库
- C# 全栈开发

---

## 38.4 自定义前端对接

### 登录流程

```javascript
// 1. 获取公钥（可选，用于RSA加密密码）
const pkeyResult = await fetch('/api/user/pkey');
const { data: { pkey, publicKey } } = await pkeyResult.json();

// 2. 登录
const loginResult = await fetch('/api/user/login', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
        username: 'admin',
        password: encryptedPassword,  // 或明文密码
        pkey: pkey,
        remember: true
    })
});
const { code, data } = await loginResult.json();

if (code === 0) {
    // 保存令牌
    localStorage.setItem('accessToken', data.accessToken);
    localStorage.setItem('refreshToken', data.refreshToken);
}
```

### 菜单获取

```javascript
// 获取用户菜单
const menuResult = await fetch('/api/user/menus', {
    headers: {
        'Authorization': `Bearer ${localStorage.getItem('accessToken')}`
    }
});
const { data: menus } = await menuResult.json();

// 菜单结构
// [
//   {
//     "id": 1,
//     "name": "系统管理",
//     "url": "/admin",
//     "icon": "fa-cog",
//     "children": [
//       { "id": 2, "name": "用户管理", "url": "/admin/user" },
//       { "id": 3, "name": "角色管理", "url": "/admin/role" }
//     ]
//   }
// ]
```

### 字段元数据驱动

```javascript
// 获取表单字段元数据
async function getFormFields(entity, kind = 'EditForm') {
    const result = await fetch(`/api/${entity}/getfields?kind=${kind}`, {
        headers: {
            'Authorization': `Bearer ${localStorage.getItem('accessToken')}`
        }
    });
    return await result.json();
}

// 根据元数据渲染表单
function renderForm(fields, formData) {
    return fields.map(field => {
        const value = formData[field.name];
        
        switch (field.type) {
            case 'String':
                if (field.dataSource) {
                    return renderSelect(field, value);
                }
                if (field.length > 200) {
                    return renderTextarea(field, value);
                }
                return renderInput(field, value);
            
            case 'Int32':
            case 'Int64':
                if (field.dataSource) {
                    return renderSelect(field, value);
                }
                return renderNumber(field, value);
            
            case 'Boolean':
                return renderSwitch(field, value);
            
            case 'DateTime':
                return renderDatePicker(field, value);
            
            default:
                return renderInput(field, value);
        }
    });
}
```

### CRUD 调用示例

```javascript
// API 封装
class CubeApi {
    constructor(baseUrl, entity) {
        this.baseUrl = baseUrl;
        this.entity = entity;
    }
    
    get headers() {
        return {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${localStorage.getItem('accessToken')}`
        };
    }
    
    // 列表查询
    async list(params = {}) {
        const query = new URLSearchParams(params).toString();
        const result = await fetch(`${this.baseUrl}/api/${this.entity}?${query}`, {
            headers: this.headers
        });
        return result.json();
    }
    
    // 详情
    async detail(id) {
        const result = await fetch(`${this.baseUrl}/api/${this.entity}/${id}`, {
            headers: this.headers
        });
        return result.json();
    }
    
    // 添加
    async add(data) {
        const result = await fetch(`${this.baseUrl}/api/${this.entity}`, {
            method: 'POST',
            headers: this.headers,
            body: JSON.stringify(data)
        });
        return result.json();
    }
    
    // 更新
    async update(id, data) {
        const result = await fetch(`${this.baseUrl}/api/${this.entity}/${id}`, {
            method: 'PUT',
            headers: this.headers,
            body: JSON.stringify({ id, ...data })
        });
        return result.json();
    }
    
    // 删除
    async delete(id) {
        const result = await fetch(`${this.baseUrl}/api/${this.entity}/${id}`, {
            method: 'DELETE',
            headers: this.headers
        });
        return result.json();
    }
    
    // 获取字段元数据
    async getFields(kind = 'List') {
        const kindMap = { List: 1, Detail: 2, AddForm: 3, EditForm: 4, Search: 5 };
        const result = await fetch(
            `${this.baseUrl}/api/${this.entity}/getfields?kind=${kindMap[kind]}`,
            { headers: this.headers }
        );
        return result.json();
    }
}

// 使用示例
const studentApi = new CubeApi('http://localhost:5000', 'student');

// 获取列表
const listResult = await studentApi.list({ pageIndex: 1, pageSize: 20 });
console.log(listResult.data);

// 添加
const addResult = await studentApi.add({ name: '张三', classId: 1 });
console.log(addResult);

// 更新
const updateResult = await studentApi.update(1, { name: '张三修改' });
console.log(updateResult);
```

### 令牌刷新

```javascript
// 请求拦截器，自动刷新令牌
async function fetchWithAuth(url, options = {}) {
    const token = localStorage.getItem('accessToken');
    
    const response = await fetch(url, {
        ...options,
        headers: {
            ...options.headers,
            'Authorization': `Bearer ${token}`
        }
    });
    
    // 401 时尝试刷新令牌
    if (response.status === 401) {
        const refreshToken = localStorage.getItem('refreshToken');
        const refreshResult = await fetch('/api/user/refresh', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ refreshToken })
        });
        
        const { code, data } = await refreshResult.json();
        if (code === 0) {
            localStorage.setItem('accessToken', data.accessToken);
            localStorage.setItem('refreshToken', data.refreshToken);
            
            // 重试原请求
            return fetch(url, {
                ...options,
                headers: {
                    ...options.headers,
                    'Authorization': `Bearer ${data.accessToken}`
                }
            });
        } else {
            // 刷新失败，跳转登录
            window.location.href = '/login';
        }
    }
    
    return response;
}
```

---

## 38.5 最佳实践

### 统一错误处理

```javascript
// 响应拦截器
async function handleResponse(response) {
    const result = await response.json();
    
    if (result.code !== 0) {
        switch (result.code) {
            case 401:
                // 未登录
                window.location.href = '/login';
                break;
            case 403:
                // 无权限
                alert('无权限访问');
                break;
            default:
                // 其他错误
                alert(result.message || '操作失败');
        }
        throw new Error(result.message);
    }
    
    return result;
}
```

### 分页组件封装

```vue
<!-- Vue 分页组件示例 -->
<template>
  <div class="pagination">
    <el-pagination
      v-model:current-page="currentPage"
      v-model:page-size="pageSize"
      :total="total"
      :page-sizes="[10, 20, 50, 100]"
      layout="total, sizes, prev, pager, next, jumper"
      @size-change="handleSizeChange"
      @current-change="handleCurrentChange"
    />
  </div>
</template>

<script setup>
import { ref, watch } from 'vue';

const props = defineProps({
  page: Object
});

const emit = defineEmits(['change']);

const currentPage = ref(props.page?.pageIndex || 1);
const pageSize = ref(props.page?.pageSize || 20);
const total = ref(props.page?.totalCount || 0);

watch(() => props.page, (newPage) => {
  if (newPage) {
    currentPage.value = newPage.pageIndex;
    pageSize.value = newPage.pageSize;
    total.value = newPage.totalCount;
  }
});

function handleSizeChange(size) {
  emit('change', { pageIndex: 1, pageSize: size });
}

function handleCurrentChange(page) {
  emit('change', { pageIndex: page, pageSize: pageSize.value });
}
</script>
```

---

## 本章小结

本章介绍了前端对接魔方 API 的方法：

1. **官方前端项目**：CubeVue、CubeAntd、CubeBlazor
2. **自定义对接**：登录、菜单、CRUD
3. **字段元数据驱动**：动态表单渲染
4. **最佳实践**：错误处理、令牌刷新

选择合适的前端框架，快速构建管理系统。

---

**下一章**：[项目架构建议](项目架构建议.md) - 了解推荐的项目架构
