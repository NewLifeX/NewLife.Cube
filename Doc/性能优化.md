# 第40章 性能优化

> 本章介绍魔方应用的性能优化技巧和最佳实践。

---

## 40.1 日志判级

### 问题

日志字符串拼接会消耗性能，即使日志级别被禁用：

```csharp
// ? 每次都会执行字符串拼接
XTrace.Log.Debug($"处理订单 {order.Id}，金额 {order.Amount}");
```

### 解决方案

使用日志级别判断：

```csharp
// ? 只有在 Debug 级别启用时才拼接字符串
if (XTrace.Log.Level <= LogLevel.Debug)
{
    XTrace.Log.Debug($"处理订单 {order.Id}，金额 {order.Amount}");
}
```

### WriteLog 方法

```csharp
/// <summary>写日志</summary>
protected virtual void WriteLog(String action, Boolean success, String remark)
{
    // 仅在启用日志时执行
    if (!success || Setting.Current.ShowSQL)
    {
        XTrace.WriteLine($"[{action}] {(success ? "成功" : "失败")} {remark}");
    }
}
```

---

## 40.2 对象池与 ArrayPool

### StringBuilder 池

```csharp
// ? 使用对象池获取 StringBuilder
var sb = Pool.StringBuilder.Get();
try
{
    sb.Append("Hello");
    sb.Append(" ");
    sb.Append("World");
    return sb.ToString();
}
finally
{
    Pool.StringBuilder.Put(sb);
}

// 或使用扩展方法
var sb = Pool.StringBuilder.Get();
sb.Append("Hello World");
var result = sb.Put(true); // 自动归还并返回字符串
```

### ArrayPool

```csharp
// ? 使用数组池减少 GC 压力
var buffer = ArrayPool<Byte>.Shared.Rent(1024);
try
{
    var count = stream.Read(buffer, 0, buffer.Length);
    // 处理数据
}
finally
{
    ArrayPool<Byte>.Shared.Return(buffer);
}
```

### MemoryStream 池

```csharp
// ? 使用内存流池
using var ms = Pool.MemoryStream.Get();
// 写入数据
ms.Write(data);
// 获取数据
var result = ms.ToArray();
// 自动归还
```

---

## 40.3 缓存策略

### 实体缓存

XCode 提供三级缓存：

```csharp
// 一级缓存：实体缓存（全表缓存，适合小表）
public static IList<Role> GetAll() => FindAllWithCache();

// 二级缓存：单对象缓存（按主键缓存）
public static Role FindById(Int32 id)
{
    if (id <= 0) return null;
    
    // 使用单对象缓存
    return Meta.SingleCache[id];
}

// 三级缓存：查询缓存（按条件缓存）
public static IList<Student> FindByClassId(Int32 classId)
{
    return Meta.Cache.Entities.FindAll(e => e.ClassId == classId);
}
```

### 扩展属性缓存

```csharp
/// <summary>班级</summary>
public Class Class => Extends.Get(nameof(Class), k => Class.FindById(ClassId));

// Extends 自动缓存扩展属性，避免重复查询
```

### 字段缓存

```csharp
// ? 缓存枚举字段的字典
private static readonly Dictionary<String, Role> _nameCache = new();

public static Role FindByName(String name)
{
    if (_nameCache.TryGetValue(name, out var role)) return role;
    
    role = Find(_.Name == name);
    if (role != null) _nameCache[name] = role;
    
    return role;
}
```

### 内存缓存

```csharp
// 使用 IMemoryCache
private readonly IMemoryCache _cache;

public StudentDto GetStudent(Int32 id)
{
    var key = $"Student:{id}";
    
    if (!_cache.TryGetValue(key, out StudentDto dto))
    {
        var student = Student.FindById(id);
        dto = student?.ToDto();
        
        _cache.Set(key, dto, TimeSpan.FromMinutes(5));
    }
    
    return dto;
}
```

---

## 40.4 分页优化

### 问题

大数据量时，COUNT 和 OFFSET 会很慢：

```sql
-- 慢：需要扫描大量数据
SELECT COUNT(*) FROM Student WHERE ClassId = 1;
SELECT * FROM Student WHERE ClassId = 1 ORDER BY Id OFFSET 10000 ROWS FETCH NEXT 20 ROWS ONLY;
```

### 优化方案

#### 1. 使用游标分页

```csharp
// ? 基于主键的游标分页
public static IList<Student> SearchByLastId(Int32 classId, Int32 lastId, Int32 pageSize)
{
    var exp = new WhereExpression();
    exp &= _.ClassId == classId;
    if (lastId > 0) exp &= _.Id > lastId;
    
    return FindAll(exp, _.Id.Asc(), null, 0, pageSize);
}
```

#### 2. 限制总数查询

```csharp
// ? 只在首页查询总数
public IList<Student> Search(StudentQuery query, Pager p)
{
    // 只有第一页才查询总数
    if (p.PageIndex == 1)
    {
        p.RetrieveTotalCount = true;
    }
    else
    {
        p.RetrieveTotalCount = false;
    }
    
    return Student.Search(query.ClassId, query.Name, p);
}
```

#### 3. 使用索引覆盖

```csharp
// 确保分页查询字段有索引
[BindIndex("IX_Student_ClassId", false, "ClassId")]
[BindIndex("IX_Student_CreateTime", false, "CreateTime")]
public partial class Student : Entity<Student>
{
}
```

---

## 40.5 异步最佳实践

### 异步方法命名

```csharp
// ? 异步方法以 Async 结尾
public async Task<Student> GetStudentAsync(Int32 id)
{
    return await Student.FindByIdAsync(id);
}
```

### ConfigureAwait

```csharp
// ? 库代码使用 ConfigureAwait(false)
public async Task<IList<Student>> SearchAsync(String name)
{
    var list = await Student.FindAllAsync(_.Name.Contains(name))
        .ConfigureAwait(false);
    return list;
}
```

### 避免 async void

```csharp
// ? 避免 async void（无法捕获异常）
public async void ProcessData() { }

// ? 使用 async Task
public async Task ProcessDataAsync() { }
```

### 批量异步

```csharp
// ? 使用 WhenAll 并行执行
public async Task<List<StudentDto>> GetStudentsAsync(Int32[] ids)
{
    var tasks = ids.Select(id => GetStudentAsync(id));
    var students = await Task.WhenAll(tasks).ConfigureAwait(false);
    return students.Where(s => s != null).ToList();
}
```

---

## 40.6 数据库优化

### 批量插入

```csharp
// ? 使用批量插入
var students = new List<Student>();
for (var i = 0; i < 1000; i++)
{
    students.Add(new Student { Name = $"学生{i}" });
}

// 批量插入，比逐条插入快很多
students.BatchInsert();
```

### 批量更新

```csharp
// ? 批量更新
Student.Update(
    _.Status == 1,           // 设置值
    _.ClassId == classId     // 条件
);
```

### 延迟加载

```csharp
// ? 使用 Select 只查询需要的字段
var names = Student.FindAll(_.ClassId == classId, null, _.Name);

// ? 使用投影减少数据传输
var list = Student.FindAll()
    .Select(e => new { e.Id, e.Name })
    .ToList();
```

### 预热缓存

```csharp
// 应用启动时预热实体缓存
public class CacheWarmupService : IHostedService
{
    public Task StartAsync(CancellationToken cancellationToken)
    {
        // 预热小表缓存
        _ = Role.Meta.Cache;
        _ = Department.Meta.Cache;
        _ = Menu.Meta.Cache;
        
        return Task.CompletedTask;
    }
    
    public Task StopAsync(CancellationToken cancellationToken) => Task.CompletedTask;
}
```

---

## 40.7 视图渲染优化

### 部分视图缓存

```cshtml
@* 缓存部分视图 *@
<cache expires-after="TimeSpan.FromMinutes(10)">
    @await Html.PartialAsync("_Menu", Model.Menus)
</cache>
```

### 减少 ViewBag 使用

```csharp
// ? 避免过度使用 ViewBag
ViewBag.Title = "学生列表";
ViewBag.Students = students;
ViewBag.Classes = classes;

// ? 使用强类型 ViewModel
public class StudentListViewModel
{
    public String Title { get; set; }
    public IList<Student> Students { get; set; }
    public IList<Class> Classes { get; set; }
}
```

### 静态资源优化

```html
<!-- ? 使用 CDN 和版本号 -->
<link href="/css/site.css?v=@DateTime.Now.Ticks" rel="stylesheet" />

<!-- ? 启用压缩 -->
<script src="/js/app.min.js"></script>
```

---

## 40.8 API 性能优化

### 响应压缩

```csharp
// Program.cs
builder.Services.AddResponseCompression(options =>
{
    options.EnableForHttps = true;
    options.Providers.Add<GzipCompressionProvider>();
});

app.UseResponseCompression();
```

### JSON 序列化优化

```csharp
// 使用 System.Text.Json 的高性能选项
builder.Services.AddControllers()
    .AddJsonOptions(options =>
    {
        options.JsonSerializerOptions.PropertyNamingPolicy = JsonNamingPolicy.CamelCase;
        options.JsonSerializerOptions.DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull;
    });
```

### 限流

```csharp
// 使用限流中间件
builder.Services.AddRateLimiter(options =>
{
    options.GlobalLimiter = PartitionedRateLimiter.Create<HttpContext, String>(context =>
        RateLimitPartition.GetFixedWindowLimiter(
            partitionKey: context.User.Identity?.Name ?? context.Request.Headers.Host.ToString(),
            factory: partition => new FixedWindowRateLimiterOptions
            {
                AutoReplenishment = true,
                PermitLimit = 100,
                Window = TimeSpan.FromMinutes(1)
            }));
});
```

---

## 40.9 监控与诊断

### 性能追踪

```csharp
// 使用 Tracer 追踪性能
public async Task<IList<Student>> SearchAsync(String name)
{
    using var span = _tracer?.NewSpan("SearchStudent", name);
    
    var list = await Student.FindAllAsync(_.Name.Contains(name));
    
    span?.AppendTag(list.Count);
    return list;
}
```

### 慢查询日志

```csharp
// 配置 XCode 慢查询日志
XCodeSetting.Current.ShowSQL = true;
XCodeSetting.Current.SQLPath = "Log";
XCodeSetting.Current.TraceSQLTime = 1000; // 超过 1 秒的查询记录日志
```

### 内存诊断

```csharp
// 记录内存使用
var before = GC.GetTotalMemory(true);
// 执行操作
var after = GC.GetTotalMemory(true);
XTrace.WriteLine($"内存增长: {(after - before) / 1024} KB");
```

---

## 40.10 性能检查清单

### 开发阶段

- [ ] 使用日志判级避免不必要的字符串拼接
- [ ] 使用对象池复用大对象
- [ ] 合理使用缓存
- [ ] 避免 N+1 查询问题
- [ ] 使用批量操作

### 上线前

- [ ] 开启响应压缩
- [ ] 配置静态资源缓存
- [ ] 检查数据库索引
- [ ] 配置连接池大小
- [ ] 压力测试验证

### 运行时

- [ ] 监控响应时间
- [ ] 监控数据库慢查询
- [ ] 监控内存使用
- [ ] 监控 CPU 使用
- [ ] 定期分析日志

---

## 本章小结

本章介绍了性能优化的关键技巧：

1. **日志判级**：避免不必要的字符串拼接
2. **对象池**：复用 StringBuilder、数组等大对象
3. **缓存策略**：实体缓存、单对象缓存、内存缓存
4. **分页优化**：游标分页、限制总数查询
5. **异步最佳实践**：ConfigureAwait、避免 async void
6. **数据库优化**：批量操作、延迟加载、索引优化

性能优化是一个持续的过程，需要结合监控数据不断改进。

---

**下一章**：[常见问题FAQ](常见问题FAQ.md) - 解答常见开发问题
