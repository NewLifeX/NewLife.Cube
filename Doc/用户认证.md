# 第12章 用户认证

> 本章介绍魔方的用户认证机制，包括本地登录、JWT 令牌和验证码服务。
> 
> 详细教程：https://newlifex.com/cube/cube_auth

---

## 12.1 魔方登录验证机制

### 认证方式概览

魔方支持多种认证方式：

| 方式 | 适用场景 | 特点 |
|------|---------|------|
| 密码登录 | Web 页面登录 | 传统方式，简单可靠 |
| SSO 登录 | 多系统集成 | 单点登录，统一身份 |
| JWT 令牌 | API 调用 | 无状态，适合前后端分离 |
| OAuth 登录 | 第三方登录 | 微信/QQ/钉钉等 |

### 认证流程

```
┌─────────┐     ┌─────────┐     ┌─────────┐     ┌─────────┐
│  用户   │────>│  登录   │────>│  验证   │────>│ 创建会话│
│         │     │  请求   │     │ 凭证   │     │/令牌    │
└─────────┘     └─────────┘     └─────────┘     └─────────┘
                                     │
                     ┌───────────────┼───────────────┐
                     v               v               v
                ┌─────────┐    ┌─────────┐    ┌─────────┐
                │密码验证 │    │SSO验证  │    │OAuth验证│
                └─────────┘    └─────────┘    └─────────┘
```

---

## 12.2 本地登录

### 用户名密码登录

```csharp
public class UserController : Controller
{
    [HttpPost]
    [AllowAnonymous]
    public ActionResult Login(String username, String password, Boolean remember = false)
    {
        // 验证验证码
        if (!ValidateCaptcha())
            return Json(new { code = 500, msg = "验证码错误" });
        
        // 检查账户锁定
        if (LoginAttemptService.IsLocked(username))
            return Json(new { code = 500, msg = "账户已锁定，请稍后再试" });
        
        // 查找用户
        var user = User.FindByName(username);
        if (user == null)
        {
            LoginAttemptService.RecordFailure(username);
            return Json(new { code = 500, msg = "用户名或密码错误" });
        }
        
        // 验证密码
        if (!user.VerifyPassword(password))
        {
            LoginAttemptService.RecordFailure(username);
            return Json(new { code = 500, msg = "用户名或密码错误" });
        }
        
        // 检查用户状态
        if (!user.Enable)
            return Json(new { code = 500, msg = "账户已禁用" });
        
        // 登录成功
        LoginAttemptService.ClearAttempts(username);
        
        // 创建会话
        ManageProvider.Provider.Current = user;
        
        // 更新登录信息
        user.LastLogin = DateTime.Now;
        user.LastLoginIP = WebHelper.UserHost;
        user.Logins++;
        user.Update();
        
        // 记录登录日志
        WriteLoginLog(user, true, "登录成功");
        
        // 返回结果
        if (remember)
        {
            // 设置持久化 Cookie
            SetRememberMeCookie(user);
        }
        
        return Json(new { code = 0, msg = "登录成功", url = "/" });
    }
}
```

### 登录接口 /Admin/User/Login

MVC 版魔方的标准登录接口：

```csharp
// 登录页面
[HttpGet]
[AllowAnonymous]
public ActionResult Login(String returnUrl = null)
{
    ViewBag.ReturnUrl = returnUrl;
    return View();
}

// 登录处理
[HttpPost]
[AllowAnonymous]
public ActionResult Login(LoginModel model)
{
    // 处理登录逻辑
}
```

### 密码强度策略

```csharp
public class PasswordPolicy
{
    /// <summary>验证密码强度</summary>
    public static (Boolean Valid, String Message) Validate(String password)
    {
        var setting = CubeSetting.Current;
        
        if (password.Length < setting.PasswordMinLength)
            return (false, $"密码长度不能少于{setting.PasswordMinLength}位");
        
        if (setting.PasswordRequireUppercase && !password.Any(Char.IsUpper))
            return (false, "密码必须包含大写字母");
        
        if (setting.PasswordRequireLowercase && !password.Any(Char.IsLower))
            return (false, "密码必须包含小写字母");
        
        if (setting.PasswordRequireDigit && !password.Any(Char.IsDigit))
            return (false, "密码必须包含数字");
        
        return (true, "密码强度符合要求");
    }
    
    /// <summary>计算密码强度分数</summary>
    public static Int32 GetStrength(String password)
    {
        var score = 0;
        
        if (password.Length >= 8) score += 20;
        if (password.Length >= 12) score += 10;
        if (password.Any(Char.IsUpper)) score += 20;
        if (password.Any(Char.IsLower)) score += 20;
        if (password.Any(Char.IsDigit)) score += 20;
        if (password.Any(c => !Char.IsLetterOrDigit(c))) score += 10;
        
        return score;
    }
}
```

### 登录失败限制

```csharp
public class LoginAttemptService
{
    private readonly ICache _cache;
    
    /// <summary>记录登录失败</summary>
    public void RecordFailure(String username)
    {
        var key = $"login:fail:{username}";
        var count = _cache.Increment(key, 1);
        _cache.SetExpire(key, TimeSpan.FromMinutes(30));
        
        // 超过限制，锁定账户
        if (count >= CubeSetting.Current.LoginMaxAttempts)
        {
            Lock(username);
        }
    }
    
    /// <summary>锁定账户</summary>
    public void Lock(String username)
    {
        var key = $"login:lock:{username}";
        _cache.Set(key, true, CubeSetting.Current.LoginLockMinutes * 60);
    }
    
    /// <summary>检查是否锁定</summary>
    public Boolean IsLocked(String username)
    {
        var key = $"login:lock:{username}";
        return _cache.Get<Boolean>(key);
    }
    
    /// <summary>清除失败记录</summary>
    public void Clear(String username)
    {
        _cache.Remove($"login:fail:{username}");
        _cache.Remove($"login:lock:{username}");
    }
}
```

---

## 12.3 JWT 令牌

### JWT 配置（JwtSecret）

```json
// appsettings.json
{
  "Cube": {
    "JwtSecret": "your-secret-key-at-least-32-characters",
    "JwtIssuer": "CubeApp",
    "JwtAudience": "CubeApi",
    "JwtExpireMinutes": 120,
    "RefreshTokenExpireDays": 7
  }
}
```

### 令牌生成

```csharp
public class TokenService
{
    private readonly CubeSetting _setting;
    
    /// <summary>生成访问令牌</summary>
    public String GenerateAccessToken(User user)
    {
        var claims = new[]
        {
            new Claim(ClaimTypes.NameIdentifier, user.Id.ToString()),
            new Claim(ClaimTypes.Name, user.Name),
            new Claim("DisplayName", user.DisplayName ?? user.Name),
            new Claim("RoleId", user.RoleId.ToString()),
            new Claim("TenantId", user.TenantId.ToString())
        };
        
        var key = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(_setting.JwtSecret));
        var creds = new SigningCredentials(key, SecurityAlgorithms.HmacSha256);
        
        var token = new JwtSecurityToken(
            issuer: _setting.JwtIssuer,
            audience: _setting.JwtAudience,
            claims: claims,
            expires: DateTime.Now.AddMinutes(_setting.JwtExpireMinutes),
            signingCredentials: creds
        );
        
        return new JwtSecurityTokenHandler().WriteToken(token);
    }
    
    /// <summary>生成刷新令牌</summary>
    public String GenerateRefreshToken()
    {
        var randomBytes = new Byte[64];
        using var rng = RandomNumberGenerator.Create();
        rng.GetBytes(randomBytes);
        return Convert.ToBase64String(randomBytes);
    }
}
```

### 令牌有效期

```csharp
// 访问令牌有效期（默认2小时）
public Int32 JwtExpireMinutes { get; set; } = 120;

// 刷新令牌有效期（默认7天）
public Int32 RefreshTokenExpireDays { get; set; } = 7;
```

### 令牌刷新机制

```csharp
[HttpPost]
[AllowAnonymous]
public ActionResult RefreshToken(String refreshToken)
{
    // 验证刷新令牌
    var token = UserToken.FindByToken(refreshToken);
    if (token == null || token.ExpireTime < DateTime.Now)
        return Json(new { code = 401, msg = "刷新令牌无效或已过期" });
    
    // 获取用户
    var user = User.FindById(token.UserId);
    if (user == null || !user.Enable)
        return Json(new { code = 401, msg = "用户不存在或已禁用" });
    
    // 生成新的访问令牌
    var accessToken = _tokenService.GenerateAccessToken(user);
    
    // 可选：生成新的刷新令牌
    var newRefreshToken = _tokenService.GenerateRefreshToken();
    token.Token = newRefreshToken;
    token.ExpireTime = DateTime.Now.AddDays(CubeSetting.Current.RefreshTokenExpireDays);
    token.Update();
    
    return Json(new
    {
        code = 0,
        data = new
        {
            accessToken,
            refreshToken = newRefreshToken,
            expiresIn = CubeSetting.Current.JwtExpireMinutes * 60
        }
    });
}
```

### 令牌传递方式

令牌可以通过多种方式传递：

```csharp
// 方式1：Authorization Header（推荐）
// Authorization: Bearer eyJhbGciOiJIUzI1NiIs...

// 方式2：Cookie
// Cookie: token=eyJhbGciOiJIUzI1NiIs...

// 方式3：Query String（不推荐，仅用于特殊场景）
// GET /api/data?token=eyJhbGciOiJIUzI1NiIs...

// 令牌解析中间件
public class TokenMiddleware
{
    public async Task InvokeAsync(HttpContext context)
    {
        var token = GetToken(context);
        if (!token.IsNullOrEmpty())
        {
            var user = ValidateToken(token);
            if (user != null)
            {
                context.User = new ClaimsPrincipal(new ClaimsIdentity(user.ToClaims()));
            }
        }
        
        await _next(context);
    }
    
    private String GetToken(HttpContext context)
    {
        // 优先从 Header 获取
        var auth = context.Request.Headers["Authorization"].ToString();
        if (auth.StartsWith("Bearer ", StringComparison.OrdinalIgnoreCase))
            return auth.Substring(7);
        
        // 其次从 Cookie 获取
        if (context.Request.Cookies.TryGetValue("token", out var cookieToken))
            return cookieToken;
        
        // 最后从 Query 获取
        return context.Request.Query["token"];
    }
}
```

---

## 12.4 验证码

### 图形验证码

```csharp
public class CaptchaController : Controller
{
    [HttpGet]
    [AllowAnonymous]
    public ActionResult GetCaptcha()
    {
        // 生成验证码
        var code = Rand.NextString(4, true);
        
        // 存储到 Session
        HttpContext.Session.SetString("Captcha", code.ToLower());
        
        // 生成图片
        var image = GenerateCaptchaImage(code);
        
        return File(image, "image/png");
    }
    
    private Byte[] GenerateCaptchaImage(String code)
    {
        using var bitmap = new Bitmap(120, 40);
        using var graphics = Graphics.FromImage(bitmap);
        
        // 背景
        graphics.Clear(Color.White);
        
        // 干扰线
        var random = new Random();
        for (int i = 0; i < 5; i++)
        {
            var x1 = random.Next(bitmap.Width);
            var y1 = random.Next(bitmap.Height);
            var x2 = random.Next(bitmap.Width);
            var y2 = random.Next(bitmap.Height);
            graphics.DrawLine(Pens.Gray, x1, y1, x2, y2);
        }
        
        // 验证码文字
        using var font = new Font("Arial", 20, FontStyle.Bold);
        using var brush = new SolidBrush(Color.Blue);
        graphics.DrawString(code, font, brush, 20, 5);
        
        // 输出
        using var ms = new MemoryStream();
        bitmap.Save(ms, ImageFormat.Png);
        return ms.ToArray();
    }
    
    /// <summary>验证验证码</summary>
    public Boolean Validate(String input)
    {
        var code = HttpContext.Session.GetString("Captcha");
        HttpContext.Session.Remove("Captcha");  // 一次性使用
        
        return code?.Equals(input, StringComparison.OrdinalIgnoreCase) ?? false;
    }
}
```

### 短信验证码

```csharp
public class SmsVerifyService
{
    private readonly ICache _cache;
    private readonly ISmsService _smsService;
    
    /// <summary>发送短信验证码</summary>
    public async Task<Boolean> SendCodeAsync(String phone)
    {
        // 防止频繁发送
        var key = $"sms:limit:{phone}";
        if (_cache.Get<Boolean>(key))
            throw new Exception("发送太频繁，请稍后再试");
        
        // 生成验证码
        var code = Rand.Next(100000, 999999).ToString();
        
        // 存储验证码（5分钟有效）
        _cache.Set($"sms:code:{phone}", code, 300);
        
        // 发送限制（60秒）
        _cache.Set(key, true, 60);
        
        // 发送短信
        return await _smsService.SendAsync(phone, $"您的验证码是：{code}，5分钟内有效。");
    }
    
    /// <summary>验证短信验证码</summary>
    public Boolean Verify(String phone, String code)
    {
        var key = $"sms:code:{phone}";
        var stored = _cache.Get<String>(key);
        
        if (stored == code)
        {
            _cache.Remove(key);  // 一次性使用
            return true;
        }
        
        return false;
    }
}
```

### 验证码服务配置

```json
// appsettings.json
{
  "Captcha": {
    "Length": 4,
    "Width": 120,
    "Height": 40,
    "ExpireSeconds": 300
  },
  "Sms": {
    "Provider": "Aliyun",
    "AccessKeyId": "your-access-key",
    "AccessKeySecret": "your-secret",
    "SignName": "魔方",
    "TemplateCode": "SMS_123456"
  }
}
```

---

## 登录流程最佳实践

### 1. 完整登录流程

```csharp
[HttpPost]
[AllowAnonymous]
public async Task<ActionResult> Login(LoginRequest request)
{
    // 1. 验证码校验
    if (!_captchaService.Validate(request.Captcha))
        return Fail("验证码错误");
    
    // 2. 账户锁定检查
    if (_loginAttempt.IsLocked(request.Username))
        return Fail("账户已锁定，请30分钟后再试");
    
    // 3. 查找用户
    var user = User.FindByName(request.Username);
    if (user == null)
    {
        _loginAttempt.RecordFailure(request.Username);
        return Fail("用户名或密码错误");
    }
    
    // 4. 密码验证
    if (!user.VerifyPassword(request.Password))
    {
        _loginAttempt.RecordFailure(request.Username);
        return Fail("用户名或密码错误");
    }
    
    // 5. 用户状态检查
    if (!user.Enable)
        return Fail("账户已禁用");
    
    // 6. 密码过期检查
    if (user.PasswordExpired)
        return Json(new { code = 1001, msg = "密码已过期，请修改密码" });
    
    // 7. 双因素认证（可选）
    if (CubeSetting.Current.TwoFactorEnabled)
    {
        await _twoFactor.SendCodeAsync(user);
        return Json(new { code = 1002, msg = "请输入短信验证码", userId = user.Id });
    }
    
    // 8. 登录成功
    return await CompleteLogin(user, request.Remember);
}

private async Task<ActionResult> CompleteLogin(User user, Boolean remember)
{
    // 清除失败记录
    _loginAttempt.Clear(user.Name);
    
    // 创建会话
    ManageProvider.Provider.Current = user;
    
    // 生成令牌
    var accessToken = _tokenService.GenerateAccessToken(user);
    var refreshToken = _tokenService.GenerateRefreshToken();
    
    // 保存刷新令牌
    SaveRefreshToken(user, refreshToken);
    
    // 更新用户信息
    user.LastLogin = DateTime.Now;
    user.LastLoginIP = WebHelper.UserHost;
    user.Logins++;
    user.Update();
    
    // 记录日志
    WriteLoginLog(user, true, "登录成功");
    
    return Json(new
    {
        code = 0,
        msg = "登录成功",
        data = new
        {
            accessToken,
            refreshToken,
            expiresIn = CubeSetting.Current.JwtExpireMinutes * 60,
            user = new { user.Id, user.Name, user.DisplayName }
        }
    });
}
```

### 2. 退出登录

```csharp
[HttpPost]
public ActionResult Logout()
{
    var user = ManageProvider.User as User;
    
    // 清除会话
    ManageProvider.Provider.Current = null;
    
    // 作废刷新令牌
    UserToken.DeleteByUserId(user.Id);
    
    // 记录日志
    WriteLoginLog(user, true, "退出登录");
    
    return Json(new { code = 0, msg = "退出成功" });
}
```

---

## 本章小结

通过本章学习，你应该掌握了：

1. **认证方式**：密码登录、SSO、JWT、OAuth
2. **本地登录**：用户名密码验证、失败限制
3. **JWT 令牌**：生成、验证、刷新机制
4. **验证码**：图形验证码和短信验证码

**下一步**：

- 学习 [OAuth 与 SSO](OAuth与SSO.md) 了解第三方登录
- 了解 [视图体系](视图体系.md) 的登录页面定制

---

## 参考资源

- [魔方登录验证机制](https://newlifex.com/cube/cube_auth)
