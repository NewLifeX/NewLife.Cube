# 第30章 控制器扩展

> 本章介绍如何扩展和自定义魔方控制器，包括继承 EntityController、重写核心方法、以及各类特殊控制器的使用。

---

## 30.1 继承 EntityController

### 控制器继承体系

魔方提供了完整的控制器继承体系，支持不同场景的数据管理需求：

```
ControllerBaseX                    # 控制器基类
├── ReadOnlyEntityController<T>    # 只读实体控制器（查看、导出）
│   └── EntityController<T,M>      # 可编辑实体控制器（完整CRUD）
│       └── EntityTreeController<T,M>  # 树形实体控制器
├── ObjectController<T>            # 对象控制器（单个对象管理）
│   └── ConfigController<T>        # 配置控制器
```

### ReadOnlyEntityController

只读实体控制器提供数据查看和导出功能，不允许编辑：

```csharp
using NewLife.Cube;
using XCode.Membership;

namespace MyApp.Areas.School.Controllers;

/// <summary>学生只读控制器</summary>
[SchoolArea]
[DisplayName("学生查看")]
public class StudentReadController : ReadOnlyEntityController<Student>
{
    static StudentReadController()
    {
        // 配置列表字段
        ListFields.RemoveField("Remark", "CreateUser", "CreateTime");
        
        // 配置搜索字段
        var sf = ListFields.AddListField("ClassId", null, "Id");
        sf.DataSource = e => Class.FindAllWithCache().ToDictionary(x => x.Id, x => x.Name);
    }
}
```

### EntityController

可编辑实体控制器支持完整的 CRUD 操作：

```csharp
using NewLife.Cube;
using XCode.Membership;

namespace MyApp.Areas.School.Controllers;

/// <summary>学生管理控制器</summary>
[SchoolArea]
[DisplayName("学生管理")]
public class StudentController : EntityController<Student>
{
    static StudentController()
    {
        // 列表字段配置
        ListFields.RemoveField("Password");
        ListFields.AddField("ClassName", "ClassId");
        
        // 表单字段配置
        AddFormFields.RemoveField("CreateUser", "CreateTime", "UpdateUser", "UpdateTime");
        EditFormFields.RemoveField("CreateUser", "CreateTime");
    }
}
```

### 带模型的 EntityController

当需要自定义输入模型时，使用带 TModel 参数的版本：

```csharp
/// <summary>学生管理控制器</summary>
[SchoolArea]
[DisplayName("学生管理")]
public class StudentController : EntityController<Student, StudentModel>
{
    // TModel 用于表单绑定，与 TEntity 分离
}

/// <summary>学生输入模型</summary>
public class StudentModel : IModel
{
    public Int32 Id { get; set; }
    public String Name { get; set; }
    public Int32 ClassId { get; set; }
    // 省略其他属性...
    
    public Object this[String name]
    {
        get => this.GetValue(name);
        set => this.SetValue(name, value);
    }
}
```

---

## 30.2 重写核心方法

### 数据查询方法

#### Search - 搜索数据

```csharp
/// <summary>搜索数据集</summary>
/// <param name="p">分页参数</param>
/// <returns></returns>
protected override IEnumerable<Student> Search(Pager p)
{
    var classId = p["ClassId"].ToInt(-1);
    var name = p["Q"];
    var start = p["dtStart"].ToDateTime();
    var end = p["dtEnd"].ToDateTime();

    // 调用实体类的 Search 方法
    return Student.Search(classId, name, start, end, p);
}
```

#### OnGetList - 获取列表数据

```csharp
/// <summary>获取列表数据</summary>
/// <param name="p">分页参数</param>
/// <param name="list">原始数据</param>
/// <returns></returns>
protected override IEnumerable<Student> OnGetList(Pager p, IEnumerable<Student> list)
{
    // 可以对数据进行二次处理
    foreach (var item in list)
    {
        // 例如：加载关联数据
        item.ClassName = item.Class?.Name;
    }
    
    return base.OnGetList(p, list);
}
```

#### OnSearch - 搜索前处理

```csharp
/// <summary>搜索前处理</summary>
/// <param name="p">分页参数</param>
/// <returns></returns>
protected override IDictionary<String, Object> OnSearch(Pager p)
{
    var dic = base.OnSearch(p);
    
    // 添加统计信息到视图
    dic["TotalStudents"] = Student.Meta.Count;
    dic["TodayNew"] = Student.FindCount(Student._.CreateTime >= DateTime.Today);
    
    return dic;
}
```

### 数据操作方法

#### OnInsert - 添加数据

```csharp
/// <summary>添加数据</summary>
/// <param name="entity">实体对象</param>
protected override void OnInsert(Student entity)
{
    // 添加前的处理逻辑
    entity.StudentNo = GenerateStudentNo();
    
    base.OnInsert(entity);
    
    // 添加后的处理逻辑
    WriteLog("AddStudent", true, $"添加学生：{entity.Name}");
}
```

#### OnUpdate - 更新数据

```csharp
/// <summary>更新数据</summary>
/// <param name="entity">实体对象</param>
protected override void OnUpdate(Student entity)
{
    // 更新前处理
    var old = Student.FindById(entity.Id);
    
    base.OnUpdate(entity);
    
    // 更新后处理，记录变更日志
    if (old.ClassId != entity.ClassId)
    {
        WriteLog("Transfer", true, $"学生[{entity.Name}]从班级[{old.ClassName}]转到[{entity.ClassName}]");
    }
}
```

#### OnDelete - 删除数据

```csharp
/// <summary>删除数据</summary>
/// <param name="entity">实体对象</param>
/// <returns></returns>
protected override Int32 OnDelete(Student entity)
{
    // 删除前检查
    if (entity.Scores.Count > 0)
        throw new Exception($"学生[{entity.Name}]存在成绩记录，无法删除！");
    
    return base.OnDelete(entity);
}
```

#### ProcessDelete - 删除处理

```csharp
/// <summary>删除处理，返回操作名称</summary>
/// <param name="entity">实体对象</param>
/// <returns>操作名称，如"删除"或"禁用"</returns>
protected override String ProcessDelete(Student entity)
{
    // 软删除：禁用而非真正删除
    if (entity.Enable)
    {
        entity.Enable = false;
        entity.Update();
        return "禁用";
    }
    else
    {
        entity.Delete();
        return "删除";
    }
}
```

### 数据验证方法

#### Valid - 验证实体

```csharp
/// <summary>验证实体对象</summary>
/// <param name="entity">实体对象</param>
/// <param name="type">操作类型</param>
/// <param name="post">是否提交</param>
/// <returns></returns>
protected override Boolean Valid(Student entity, DataObjectMethodType type, Boolean post)
{
    if (post)
    {
        // 验证必填字段
        if (entity.Name.IsNullOrWhiteSpace())
            throw new ArgumentNullException(nameof(entity.Name), "学生姓名不能为空！");
        
        // 验证唯一性
        if (type == DataObjectMethodType.Insert)
        {
            var exist = Student.FindByStudentNo(entity.StudentNo);
            if (exist != null)
                throw new ArgumentException($"学号[{entity.StudentNo}]已存在！");
        }
        
        // 验证数据权限
        var user = ManageProvider.User;
        if (!user.Roles.Any(e => e.IsSystem))
        {
            // 非管理员只能操作自己创建的数据
            if (type == DataObjectMethodType.Update && entity.CreateUserID != user.ID)
                throw new InvalidOperationException("无权修改他人创建的数据！");
        }
    }
    
    return base.Valid(entity, type, post);
}
```

### 导出方法

#### ExportData - 导出数据

```csharp
/// <summary>导出数据</summary>
/// <param name="maxCount">最大导出数量，0表示不限</param>
/// <returns></returns>
protected override IEnumerable<Student> ExportData(Int32 maxCount = 0)
{
    var p = GetCachePager();
    
    // 限制导出数量
    if (maxCount > 0) p.PageSize = maxCount;
    else p.PageSize = 10000;
    
    // 使用搜索条件导出
    return Search(p);
}
```

#### OnExportXml / OnExportJson - 导出格式

```csharp
/// <summary>要导出Xml的对象</summary>
protected override Object OnExportXml()
{
    var list = ExportData();
    // 可以自定义导出的数据结构
    return list.Select(e => new
    {
        e.Id,
        e.Name,
        e.StudentNo,
        ClassName = e.Class?.Name
    }).ToList();
}

/// <summary>要导出Json的对象</summary>
protected override Object OnExportJson() => OnExportXml();
```

---

## 30.3 ReadOnlyEntityController（只读控制器）

只读控制器适用于只需要查看数据的场景，如报表、日志查看等。

### 主要特点

- 仅支持查看和导出，不支持增删改
- 权限要求低，仅需 Detail 权限
- 适合展示汇总数据、历史记录等

### 使用示例

```csharp
/// <summary>操作日志查看</summary>
[AdminArea]
[DisplayName("操作日志")]
public class LogController : ReadOnlyEntityController<Log>
{
    static LogController()
    {
        // 日志只读，不需要编辑按钮
        ListFields.RemoveField("Id");
        
        // 按时间倒序显示
        PageSetting.Sort = "Id Desc";
    }
    
    protected override IEnumerable<Log> Search(Pager p)
    {
        var category = p["category"];
        var action = p["action"];
        var start = p["dtStart"].ToDateTime();
        var end = p["dtEnd"].ToDateTime();
        
        return Log.Search(category, action, start, end, p);
    }
}
```

---

## 30.4 EntityTreeController（树形控制器）

树形控制器用于管理具有父子层级关系的数据，如菜单、部门、分类等。

### 主要特点

- 自动处理树形结构的展示
- 支持上移、下移操作
- 自动排序和缩进显示
- 使用 ListTree 视图

### 使用示例

```csharp
/// <summary>部门管理</summary>
[AdminArea]
[DisplayName("部门管理")]
public class DepartmentController : EntityTreeController<Department>
{
    static DepartmentController()
    {
        ListFields.RemoveField("Remark");
    }
    
    /// <summary>搜索数据集</summary>
    protected override IEnumerable<Department> Search(Pager p)
    {
        var parentId = p["ParentID"].ToInt(-1);
        
        // 根据父节点筛选
        if (parentId >= 0)
            return Department.FindAllChildsByParent(parentId);
        
        // 默认显示整棵树
        return Department.Root.AllChilds;
    }
}
```

### 树形实体要求

树形控制器要求实体继承自 `EntityTree<T>`：

```csharp
public class Department : EntityTree<Department>
{
    // EntityTree 提供树形操作方法
    // - Parent: 父节点
    // - Childs: 子节点集合
    // - AllChilds: 所有子孙节点
    // - Up()/Down(): 上移/下移
}
```

---

## 30.5 ConfigController（配置控制器）

配置控制器用于管理单个配置对象，如系统设置。

### 使用示例

```csharp
/// <summary>系统配置</summary>
[AdminArea]
[DisplayName("系统配置")]
public class SysConfigController : ConfigController<SysConfig>
{
    // 自动读取和保存 SysConfig.Current
}

/// <summary>系统配置类</summary>
public class SysConfig : Config<SysConfig>
{
    /// <summary>系统名称</summary>
    [Description("系统名称")]
    public String Name { get; set; } = "魔方管理系统";
    
    /// <summary>每页显示数量</summary>
    [Description("每页显示数量")]
    public Int32 PageSize { get; set; } = 20;
    
    /// <summary>是否开发模式</summary>
    [Description("是否开发模式")]
    public Boolean Develop { get; set; }
}
```

### 配置控制器特点

- 自动绑定 `Config<T>.Current`
- 保存时自动持久化到配置文件
- 支持属性分组显示
- 使用 ObjectForm 视图

---

## 30.6 ObjectController（对象控制器）

对象控制器用于管理单个对象（非实体），适合展示运行时对象。

### 使用示例

```csharp
/// <summary>系统信息</summary>
[AdminArea]
[DisplayName("系统信息")]
public class SysInfoController : ObjectController<SystemInfo>
{
    protected override SystemInfo Value
    {
        get
        {
            return new SystemInfo
            {
                MachineName = Environment.MachineName,
                OSVersion = Environment.OSVersion.ToString(),
                ProcessorCount = Environment.ProcessorCount,
                WorkingSet = Environment.WorkingSet / 1024 / 1024,
                // ...
            };
        }
        set { }  // 只读，不支持修改
    }
}

public class SystemInfo
{
    [DisplayName("机器名")]
    public String MachineName { get; set; }
    
    [DisplayName("操作系统")]
    public String OSVersion { get; set; }
    
    [DisplayName("处理器数")]
    public Int32 ProcessorCount { get; set; }
    
    [DisplayName("内存占用(MB)")]
    public Int64 WorkingSet { get; set; }
}
```

---

## 30.7 区域注册（AreaRegistration）

### 区域特性定义

每个功能模块通常定义为一个区域：

```csharp
using NewLife.Cube;

namespace MyApp.Areas.School;

/// <summary>学校区域</summary>
[Menu(100, true, Icon = "fa-graduation-cap")]
public class SchoolArea : AreaBase
{
    /// <summary>区域名称</summary>
    public static String AreaName => nameof(SchoolArea).TrimEnd("Area");

    /// <inheritdoc />
    public SchoolArea() : base(AreaName) { }
}

/// <summary>学校区域特性</summary>
public class SchoolAreaAttribute : AreaAttribute
{
    /// <inheritdoc />
    public SchoolAreaAttribute() : base(SchoolArea.AreaName) { }
}
```

### 区域配置

```csharp
/// <summary>区域基类</summary>
public abstract class AreaBase : Area
{
    /// <summary>实例化</summary>
    /// <param name="areaName">区域名称</param>
    protected AreaBase(String areaName) : base(areaName) { }
}
```

### 菜单特性

使用 `MenuAttribute` 配置区域菜单：

```csharp
/// <summary>菜单特性</summary>
[AttributeUsage(AttributeTargets.Class)]
public class MenuAttribute : Attribute
{
    /// <summary>排序</summary>
    public Int32 Order { get; set; }
    
    /// <summary>可见</summary>
    public Boolean Visible { get; set; }
    
    /// <summary>图标</summary>
    public String Icon { get; set; }
    
    /// <summary>实例化</summary>
    /// <param name="order">排序</param>
    /// <param name="visible">可见</param>
    public MenuAttribute(Int32 order = 0, Boolean visible = true)
    {
        Order = order;
        Visible = visible;
    }
}
```

---

## 30.8 控制器扩展最佳实践

### 1. 静态构造器配置字段

```csharp
static StudentController()
{
    // 列表字段
    ListFields.RemoveField("Password", "Remark");
    ListFields.AddField("ClassName", "ClassId");
    
    // 添加表单字段
    AddFormFields.RemoveCreateUpdateFields();
    
    // 编辑表单字段
    EditFormFields.RemoveCreateFields();
    
    // 搜索字段
    var sf = ListFields.AddListField("ClassId", null, "Id");
    sf.DataSource = e => Class.FindAllWithCache().ToDictionary(x => x.Id, x => x.Name);
}
```

### 2. 统一异常处理

```csharp
protected override Boolean Valid(Student entity, DataObjectMethodType type, Boolean post)
{
    if (post)
    {
        try
        {
            // 验证逻辑
            ValidateStudent(entity);
        }
        catch (Exception ex)
        {
            // 记录日志
            WriteLog(type.ToString(), false, ex.Message);
            throw;
        }
    }
    
    return base.Valid(entity, type, post);
}
```

### 3. 权限控制

```csharp
/// <summary>删除需要特殊权限</summary>
[EntityAuthorize(PermissionFlags.Delete)]
public override ActionResult Delete(String id)
{
    // 检查是否有特殊删除权限
    var user = ManageProvider.User;
    if (!user.Has(PermissionFlags.Delete, "Student/HardDelete"))
        throw new InvalidOperationException("无权限执行硬删除！");
    
    return base.Delete(id);
}
```

### 4. 日志记录

```csharp
protected override void OnInsert(Student entity)
{
    base.OnInsert(entity);
    
    // 记录业务日志
    LogProvider.Provider.WriteLog("Student", "Add", true, 
        $"添加学生：{entity.Name}，学号：{entity.StudentNo}");
}
```

---

## 本章小结

本章介绍了魔方控制器扩展的核心内容：

1. **控制器继承体系**：从只读控制器到完整 CRUD 控制器
2. **核心方法重写**：Search、OnInsert、OnUpdate、OnDelete、Valid
3. **特殊控制器**：树形控制器、配置控制器、对象控制器
4. **区域注册**：模块化组织控制器

掌握这些内容后，您可以灵活定制各类数据管理功能，满足复杂的业务需求。

---

**下一章**：[服务扩展](服务扩展.md) - 了解如何扩展魔方的核心服务
