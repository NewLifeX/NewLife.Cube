# 第32章 中间件与过滤器

> 本章介绍魔方的中间件和过滤器机制，包括 RunTimeMiddleware、DataScopeMiddleware、EntityAuthorizeAttribute 等核心组件。

---

## 32.1 RunTimeMiddleware（运行时间中间件）

### 功能概述

`RunTimeMiddleware` 是魔方的核心中间件，提供以下功能：

- 请求执行时间统计
- 用户代理（浏览器）解析
- 爬虫识别与拦截
- HTTPS 强制跳转
- 用户在线状态管理
- 安全访问规则验证
- 异常拦截与处理
- SQL 语句收集（开发模式）

### 中间件实现

```csharp
public class RunTimeMiddleware
{
    private readonly RequestDelegate _next;
    private readonly UserService _userService;
    private readonly AccessService _accessService;
    
    public RunTimeMiddleware(RequestDelegate next, UserService userService, AccessService accessService)
    {
        _next = next ?? throw new ArgumentNullException(nameof(next));
        _userService = userService;
        _accessService = accessService;
    }
    
    public async Task Invoke(HttpContext ctx)
    {
        // 1. 解析浏览器信息
        var userAgent = ctx.Request.Headers.UserAgent + "";
        var ua = new UserAgentParser();
        ua.Parse(userAgent);
        ctx.Items["UserAgent"] = ua;
        
        // 2. 识别拦截爬虫
        if (!WebHelper.ValidRobot(ctx, ua)) return;
        
        // 3. 强制访问Https
        if (MiddlewareHelper.CheckForceRedirect(ctx)) return;
        
        // 4. 创建Session集合
        var session = CreateSession(ctx);
        
        // 5. 获取请求信息
        var url = ctx.Request.GetRawUrl();
        var ip = ctx.GetUserHost();
        ManageProvider.UserHost = ip;
        
        // 6. 获取当前用户
        var user = ManageProvider.User;
        
        // 7. 安全访问规则验证
        var rule = _accessService.Valid(url + "", ua, ip, user, session);
        if (rule != null && rule.ActionKind is AccessActionKinds.Block or AccessActionKinds.Limit)
        {
            if (rule.BlockCode == 302)
                ctx.Response.Redirect(rule.BlockContent);
            else if (rule.BlockCode > 0)
            {
                ctx.Response.StatusCode = rule.BlockCode;
                await ctx.Response.WriteAsync(rule.BlockContent);
            }
            else
                ctx.Abort();
            return;
        }
        
        // 8. 记录运行时信息
        var inf = new RunTimeInfo();
        ctx.Items[nameof(RunTimeInfo)] = inf;
        
        var query = DAL.QueryTimes;
        var execute = DAL.ExecuteTimes;
        var sw = Stopwatch.StartNew();
        
        inf.QueryTimes = query;
        inf.ExecuteTimes = execute;
        inf.Watch = sw;
        
        // 9. 开发模式收集SQL语句
        if (SysConfig.Current.Develop)
        {
            inf.Sqls = new List<String>();
            DAL.LocalFilter = s => inf.Sqls.Add(s);
        }
        
        try
        {
            // 10. 用户在线状态管理
            // ...
            
            await _next.Invoke(ctx);
        }
        catch (Exception ex)
        {
            // 11. 异常处理
            XTrace.WriteException(ex);
            ctx.Items["Exception"] = new ErrorModel { /*...*/ };
            throw;
        }
        finally
        {
            // 12. 统计执行时间
            sw.Stop();
            inf.DbRunTime = DAL.QueryTimes - query + DAL.ExecuteTimes - execute;
        }
    }
}
```

### 运行时信息

```csharp
/// <summary>运行时信息</summary>
public class RunTimeInfo
{
    /// <summary>查询次数</summary>
    public Int64 QueryTimes { get; set; }
    
    /// <summary>执行次数</summary>
    public Int64 ExecuteTimes { get; set; }
    
    /// <summary>数据库执行时间</summary>
    public Int64 DbRunTime { get; set; }
    
    /// <summary>计时器</summary>
    public Stopwatch Watch { get; set; }
    
    /// <summary>SQL语句集合（开发模式）</summary>
    public IList<String> Sqls { get; set; }
}
```

### 使用运行时信息

```csharp
// 在控制器或视图中获取运行时信息
public ActionResult Index()
{
    var inf = HttpContext.Items[nameof(RunTimeInfo)] as RunTimeInfo;
    if (inf != null)
    {
        ViewBag.QueryTimes = DAL.QueryTimes - inf.QueryTimes;
        ViewBag.ExecuteTimes = DAL.ExecuteTimes - inf.ExecuteTimes;
        ViewBag.RunTime = inf.Watch.ElapsedMilliseconds;
    }
    
    return View();
}
```

---

## 32.2 DataScopeMiddleware（数据范围中间件）

### 功能概述

`DataScopeMiddleware` 负责设置租户上下文和数据权限上下文：

- 设置租户上下文（多租户）
- 设置数据权限上下文
- 影响 XCode 的数据查询范围

### 中间件实现

```csharp
public class DataScopeMiddleware
{
    private readonly RequestDelegate _next;
    
    public DataScopeMiddleware(RequestDelegate next)
    {
        _next = next ?? throw new ArgumentNullException(nameof(next));
    }
    
    public async Task Invoke(HttpContext ctx)
    {
        var tenantChanged = false;
        var dataScopeChanged = false;
        
        try
        {
            // 1. 设置租户上下文
            var set = CubeSetting.Current;
            if (set.EnableTenant && TenantContext.Current == null)
            {
                var tenantId = ctx.GetTenantId();
                if (tenantId >= 0)
                {
                    ctx.SetTenant(tenantId);
                    tenantChanged = true;
                }
            }
            
            // 2. 设置数据权限上下文
            if (DataScopeContext.Current == null)
            {
                var user = ManageProvider.User;
                var url = ctx.Request.Path + "";
                var menu = ManageProvider.Menu?.FindByUrl(url);
                
                DataScopeContext.Current = DataScopeContext.Create(user, menu);
                dataScopeChanged = true;
            }
            
            await _next.Invoke(ctx);
        }
        finally
        {
            // 清理上下文
            if (tenantChanged) TenantContext.Current = null;
            if (dataScopeChanged) DataScopeContext.Current = null;
        }
    }
}
```

### 数据范围上下文

```csharp
/// <summary>数据范围上下文</summary>
public class DataScopeContext
{
    /// <summary>当前上下文</summary>
    public static DataScopeContext Current { get; set; }
    
    /// <summary>用户</summary>
    public IManageUser User { get; set; }
    
    /// <summary>菜单</summary>
    public IMenu Menu { get; set; }
    
    /// <summary>数据范围</summary>
    public DataScope Scope { get; set; }
    
    /// <summary>创建数据范围上下文</summary>
    public static DataScopeContext Create(IManageUser user, IMenu menu)
    {
        return new DataScopeContext
        {
            User = user,
            Menu = menu,
            Scope = GetDataScope(user, menu)
        };
    }
}
```

---

## 32.3 ApiFilterAttribute（API过滤器）

### 功能概述

`ApiFilterAttribute` 是 WebAPI 版魔方的统一过滤器：

- 解析访问令牌
- 包装响应结果为标准 JSON 格式
- 拦截异常，包装为标准 JSON 格式

### 过滤器实现

```csharp
/// <summary>统一Api过滤处理</summary>
public sealed class ApiFilterAttribute : ActionFilterAttribute
{
    /// <summary>执行前，验证模型</summary>
    public override void OnActionExecuting(ActionExecutingContext context)
    {
        // 加载访问令牌
        var token = context.HttpContext.LoadToken();
        context.HttpContext.Items["Token"] = token;
        if (!context.ActionArguments.ContainsKey("token"))
            context.ActionArguments.Add("token", token);
        
        base.OnActionExecuting(context);
    }
    
    /// <summary>执行后，包装结果和异常</summary>
    public override void OnActionExecuted(ActionExecutedContext context)
    {
        // WebSocket请求不处理
        if (context.HttpContext.WebSockets.IsWebSocketRequest) return;
        
        if (context.Result != null)
        {
            // 包装ObjectResult
            if (context.Result is ObjectResult obj)
            {
                context.Result = new JsonResult(new
                {
                    code = obj.StatusCode ?? 0,
                    data = obj.Value
                });
            }
            // 包装EmptyResult
            else if (context.Result is EmptyResult)
            {
                context.Result = new JsonResult(new { code = 0, data = new { } });
            }
        }
        
        // 异常处理
        if (context.Exception != null && !context.ExceptionHandled)
        {
            var ex = context.Exception.GetTrue();
            
            if (ex is ApiException aex)
            {
                context.Result = new JsonResult(new
                {
                    code = aex.Code,
                    message = aex.Message
                });
            }
            else
            {
                context.Result = new JsonResult(new
                {
                    code = 500,
                    message = ex.Message
                });
                
                // 埋点拦截业务异常
                DefaultTracer.Instance?.NewError(context.HttpContext.Request.Path, ex);
            }
            
            context.ExceptionHandled = true;
        }
        
        base.OnActionExecuted(context);
    }
}
```

### 使用 ApiFilter

```csharp
// 全局注册
services.Configure<MvcOptions>(options =>
{
    options.Filters.Add<ApiFilterAttribute>();
});

// 或在控制器上使用
[ApiFilter]
public class MyApiController : ControllerBase
{
    [HttpGet]
    public Object GetData()
    {
        return new { name = "test" };
        // 返回：{ code: 0, data: { name: "test" } }
    }
}
```

---

## 32.4 EntityAuthorizeAttribute（实体授权特性）

### 功能概述

`EntityAuthorizeAttribute` 是魔方的核心权限验证过滤器：

- 验证用户是否登录
- 验证用户是否有权限访问菜单
- 自动解析菜单并创建
- 支持匿名访问标记

### 过滤器实现

```csharp
/// <summary>实体授权特性</summary>
public class EntityAuthorizeAttribute : Attribute, IAuthorizationFilter
{
    /// <summary>授权项</summary>
    public PermissionFlags Permission { get; }
    
    /// <summary>实例化实体授权特性</summary>
    public EntityAuthorizeAttribute() { }
    
    /// <summary>实例化实体授权特性</summary>
    /// <param name="permission">权限标志</param>
    public EntityAuthorizeAttribute(PermissionFlags permission)
    {
        Permission = permission;
    }
    
    /// <summary>授权发生时触发</summary>
    public void OnAuthorization(AuthorizationFilterContext filterContext)
    {
        var ctrl = (ControllerActionDescriptor)filterContext.ActionDescriptor;
        
        // 允许匿名访问时，直接跳过检查
        if (ctrl.MethodInfo.IsDefined(typeof(AllowAnonymousAttribute)) ||
            ctrl.ControllerTypeInfo.IsDefined(typeof(AllowAnonymousAttribute)))
            return;
        
        // 检查是否有EntityAuthorize特性
        var hasAtt = ctrl.MethodInfo.IsDefined(typeof(EntityAuthorizeAttribute), true) ||
                     ctrl.ControllerTypeInfo.IsDefined(typeof(EntityAuthorizeAttribute));
        
        // 只验证魔方区域内的控制器
        var create = false;
        if (!AreaBase.Contains(ctrl))
        {
            if (!hasAtt) return;
            create = true;  // 非魔方区域但有特性，需要创建菜单
        }
        
        // 解析菜单
        var menu = ResolveMenu(filterContext, create);
        
        // 验证权限
        if (!AuthorizeCore(filterContext.HttpContext, menu, out var user))
        {
            HandleUnauthorizedRequest(filterContext, menu, user);
        }
    }
    
    private Boolean AuthorizeCore(HttpContext httpContext, IMenu menu, out IManageUser user)
    {
        var prv = ManageProvider.Provider;
        
        // 判断当前登录用户
        user = ManagerProviderHelper.TryLogin(prv, httpContext);
        if (user == null) return false;
        
        // 如果没有指定权限，则只要登录即可
        if (Permission == PermissionFlags.None) return true;
        
        // 判断权限
        if (menu != null && user is IUser user2)
            return user2.Has(menu, Permission);
        
        return false;
    }
    
    private void HandleUnauthorizedRequest(AuthorizationFilterContext context, IMenu menu, IManageUser user)
    {
        var prv = ManageProvider.Provider;
        
        if (prv?.Current == null)
        {
            // 未登录
            if (context.HttpContext.Request.IsAjaxRequest())
            {
                context.HttpContext.Response.StatusCode = 401;
                context.Result = new JsonResult(new { code = 401, message = "没有登录或登录超时！" });
            }
            else
            {
                var retUrl = context.HttpContext.Request.GetEncodedPathAndQuery();
                var rurl = "~/Admin/User/Login".AppendReturn(retUrl);
                context.Result = new RedirectResult(rurl);
            }
        }
        else
        {
            // 已登录但无权限
            context.Result = NoPermission(context, menu, Permission, user);
        }
    }
}
```

### 权限标志

```csharp
/// <summary>权限标志</summary>
[Flags]
public enum PermissionFlags
{
    /// <summary>无权限</summary>
    None = 0,
    
    /// <summary>查看权限</summary>
    Detail = 1,
    
    /// <summary>添加权限</summary>
    Insert = 2,
    
    /// <summary>修改权限</summary>
    Update = 4,
    
    /// <summary>删除权限</summary>
    Delete = 8,
    
    /// <summary>全部权限</summary>
    All = 0xFF
}
```

### 使用示例

```csharp
/// <summary>学生管理</summary>
public class StudentController : EntityController<Student>
{
    /// <summary>列表页，需要查看权限</summary>
    [EntityAuthorize(PermissionFlags.Detail)]
    public ActionResult Index() => base.Index();
    
    /// <summary>添加页，需要添加权限</summary>
    [EntityAuthorize(PermissionFlags.Insert)]
    public ActionResult Add() => base.Add();
    
    /// <summary>编辑页，需要修改权限</summary>
    [EntityAuthorize(PermissionFlags.Update)]
    public ActionResult Edit(String id) => base.Edit(id);
    
    /// <summary>删除，需要删除权限</summary>
    [EntityAuthorize(PermissionFlags.Delete)]
    public ActionResult Delete(String id) => base.Delete(id);
    
    /// <summary>公开接口，允许匿名访问</summary>
    [AllowAnonymous]
    public ActionResult Public() => Ok("公开数据");
}
```

---

## 32.5 DataPermissionAttribute（数据权限特性）

### 功能概述

`DataPermissionAttribute` 提供数据级别的权限过滤：

- 指定不受限制的系统角色
- 定义数据权限表达式
- 支持动态变量替换

### 特性定义

```csharp
/// <summary>数据权限过滤器</summary>
public class DataPermissionAttribute : Attribute
{
    /// <summary>不受数据权限限制的系统角色</summary>
    public String SystemRoles { get; set; }
    
    /// <summary>数据权限表达式</summary>
    /// <remarks>
    /// 用于构造查询条件，支持变量：
    /// - {#SiteIds}: 用户可访问的站点ID集合
    /// - {$user.Id}: 当前用户ID
    /// - {$user.DepartmentId}: 当前用户部门ID
    /// </remarks>
    public String Expression { get; set; }
    
    /// <summary>数据权限过滤器</summary>
    public DataPermissionAttribute(String systemRoles, String expression)
    {
        SystemRoles = systemRoles;
        Expression = expression;
    }
    
    /// <summary>验证是否系统角色</summary>
    public Boolean Valid(IRole[] roles)
    {
        if (SystemRoles.IsNullOrEmpty()) return false;
        
        var srs = SystemRoles.Split(',', ';');
        return roles.Any(e => srs.Contains(e.Name));
    }
}
```

### 使用示例

```csharp
/// <summary>订单管理</summary>
[DataPermission("管理员,系统", "CreateUserID={$user.Id}")]
public class OrderController : EntityController<Order>
{
    protected override IEnumerable<Order> Search(Pager p)
    {
        var user = ManageProvider.User;
        
        // 检查数据权限
        var att = GetType().GetCustomAttribute<DataPermissionAttribute>();
        if (att != null && !att.Valid(user.Roles))
        {
            // 应用数据权限表达式
            var exp = ParseExpression(att.Expression);
            return Order.Search(exp, p);
        }
        
        return base.Search(p);
    }
}
```

---

## 32.6 自定义中间件

### 创建自定义中间件

```csharp
/// <summary>请求日志中间件</summary>
public class RequestLoggingMiddleware
{
    private readonly RequestDelegate _next;
    private readonly ILogger<RequestLoggingMiddleware> _logger;
    
    public RequestLoggingMiddleware(RequestDelegate next, ILogger<RequestLoggingMiddleware> logger)
    {
        _next = next;
        _logger = logger;
    }
    
    public async Task Invoke(HttpContext context)
    {
        var sw = Stopwatch.StartNew();
        
        // 记录请求开始
        _logger.LogInformation("请求开始: {Method} {Path}",
            context.Request.Method,
            context.Request.Path);
        
        try
        {
            await _next(context);
        }
        finally
        {
            sw.Stop();
            
            // 记录请求结束
            _logger.LogInformation("请求结束: {Method} {Path} {StatusCode} {Elapsed}ms",
                context.Request.Method,
                context.Request.Path,
                context.Response.StatusCode,
                sw.ElapsedMilliseconds);
        }
    }
}

// 扩展方法
public static class RequestLoggingMiddlewareExtensions
{
    public static IApplicationBuilder UseRequestLogging(this IApplicationBuilder app)
    {
        return app.UseMiddleware<RequestLoggingMiddleware>();
    }
}
```

### 注册自定义中间件

```csharp
var app = builder.Build();

// 在 UseCube 之前或之后注册
app.UseRequestLogging();
app.UseCube(app.Environment);
```

---

## 32.7 自定义过滤器

### 创建自定义过滤器

```csharp
/// <summary>操作日志过滤器</summary>
public class AuditLogAttribute : ActionFilterAttribute
{
    /// <summary>操作名称</summary>
    public String Action { get; set; }
    
    public AuditLogAttribute(String action = null)
    {
        Action = action;
    }
    
    public override void OnActionExecuted(ActionExecutedContext context)
    {
        var user = ManageProvider.User;
        var ip = context.HttpContext.GetUserHost();
        
        var action = Action;
        if (action.IsNullOrEmpty())
        {
            var ctrl = context.ActionDescriptor as ControllerActionDescriptor;
            action = $"{ctrl?.ControllerName}/{ctrl?.ActionName}";
        }
        
        // 记录审计日志
        LogProvider.Provider?.WriteLog(
            "审计",
            action,
            context.Exception == null,
            $"用户操作: {action}",
            user?.ID ?? 0,
            user?.ToString(),
            ip);
        
        base.OnActionExecuted(context);
    }
}
```

### 使用自定义过滤器

```csharp
// 方式1：在Action上使用
[AuditLog("导出数据")]
public ActionResult Export() { }

// 方式2：在控制器上使用
[AuditLog]
public class SensitiveController : Controller { }

// 方式3：全局注册
services.Configure<MvcOptions>(options =>
{
    options.Filters.Add<AuditLogAttribute>();
});
```

---

## 32.8 中间件与过滤器的执行顺序

### 执行管道

```
请求 → 中间件1 → 中间件2 → ... → 路由 → 过滤器 → Action → 过滤器 → ... → 中间件2 → 中间件1 → 响应
```

### 魔方默认顺序

```csharp
app.UseStaticFiles();
app.UseRouting();

// RunTimeMiddleware - 运行时间统计、安全验证
app.UseMiddleware<RunTimeMiddleware>();

// DataScopeMiddleware - 数据范围设置
app.UseMiddleware<DataScopeMiddleware>();

app.UseAuthentication();
app.UseAuthorization();

app.UseEndpoints(endpoints =>
{
    endpoints.MapControllerRoute(...);
});
```

### 过滤器执行顺序

```
Authorization Filter → Resource Filter → Action Filter → Action → Action Filter → Result Filter → Result
```

---

## 本章小结

本章介绍了魔方的中间件和过滤器机制：

1. **RunTimeMiddleware**：核心中间件，统计运行时间、安全验证
2. **DataScopeMiddleware**：设置租户和数据权限上下文
3. **ApiFilterAttribute**：API 响应包装和异常处理
4. **EntityAuthorizeAttribute**：实体授权验证
5. **DataPermissionAttribute**：数据级别权限过滤

掌握这些组件的使用方式，可以灵活定制魔方的请求处理流程。

---

**下一章**：[模型绑定](模型绑定.md) - 了解魔方的模型绑定机制
