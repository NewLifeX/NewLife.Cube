# 第33章 模型绑定

> 本章介绍魔方的模型绑定机制，包括 PagerModelBinder、EntityModelBinder、JsonModelBinder 等自定义绑定器的使用。

---

## 33.1 PagerModelBinder（分页绑定器）

### 功能概述

`PagerModelBinder` 用于自动绑定分页参数，支持从 Query、Form、Body 等多个来源获取参数。

### 绑定器实现

```csharp
/// <summary>分页模型绑定器</summary>
public class PagerModelBinder : IModelBinder
{
    private readonly IDictionary<ModelMetadata, IModelBinder> _propertyBinders;
    private readonly ILoggerFactory _loggerFactory;
    
    public PagerModelBinder(IDictionary<ModelMetadata, IModelBinder> propertyBinders, ILoggerFactory loggerFactory)
    {
        _propertyBinders = propertyBinders ?? throw new ArgumentNullException(nameof(propertyBinders));
        _loggerFactory = loggerFactory ?? throw new ArgumentNullException(nameof(loggerFactory));
    }
    
    public async Task BindModelAsync(ModelBindingContext bindingContext)
    {
        var modelType = bindingContext.ModelType;
        
        if (modelType == typeof(Pager) || modelType == typeof(PageParameter))
        {
            // 创建分页对象，自动获取请求参数
            var pager = new Pager
            {
                Params = WebHelper.Params
            };
            
            // 从路由获取id参数
            var routes = bindingContext.ActionContext.RouteData.Values;
            if (!pager.Params.ContainsKey("id") && routes.TryGetValue("id", out var id))
                pager.Params["id"] = id + "";
            
            // 尝试从body读取json格式的参数
            var entityBody = bindingContext.HttpContext.Request.GetRequestBody<Object>()
                as NullableDictionary<String, Object>;
            if (entityBody != null)
            {
                foreach (var (key, _) in _propertyBinders)
                {
                    var v = entityBody[key.Name]?.ToString();
                    if (!v.IsNullOrWhiteSpace())
                        pager[key.Name] = v;
                }
                
                bindingContext.Result = ModelBindingResult.Success(pager);
                return;
            }
            
            // 使用默认绑定器绑定其他属性
            var complexTypeModelBinder = new ComplexTypeModelBinder(_propertyBinders, _loggerFactory);
            bindingContext.Model = pager;
            await complexTypeModelBinder.BindModelAsync(bindingContext);
        }
    }
}
```

### 绑定器提供者

```csharp
/// <summary>分页模型绑定器提供者</summary>
public class PagerModelBinderProvider : IModelBinderProvider
{
    public IModelBinder GetBinder(ModelBinderProviderContext context)
    {
        var modelType = context.Metadata.ModelType;
        
        // 只处理 Pager 和 PageParameter 类型
        if (modelType == typeof(Pager) || modelType == typeof(PageParameter))
        {
            var propertyBinders = new Dictionary<ModelMetadata, IModelBinder>();
            foreach (var property in context.Metadata.Properties)
            {
                propertyBinders.Add(property, context.CreateBinder(property));
            }
            
            var loggerFactory = context.Services.GetRequiredService<ILoggerFactory>();
            return new PagerModelBinder(propertyBinders, loggerFactory);
        }
        
        return null;
    }
}
```

### 使用示例

```csharp
// 控制器中直接使用 Pager 参数
public ActionResult Index(Pager p)
{
    // p 自动从请求参数绑定
    // 支持：?PageIndex=1&PageSize=20&Sort=Id&Desc=true
    
    var list = Student.Search(p);
    return View(list);
}

// Pager 类的主要属性
public class Pager
{
    /// <summary>页码，从1开始</summary>
    public Int32 PageIndex { get; set; } = 1;
    
    /// <summary>每页大小</summary>
    public Int32 PageSize { get; set; } = 20;
    
    /// <summary>排序字段</summary>
    public String Sort { get; set; }
    
    /// <summary>是否降序</summary>
    public Boolean Desc { get; set; }
    
    /// <summary>总记录数</summary>
    public Int64 TotalCount { get; set; }
    
    /// <summary>参数字典</summary>
    public IDictionary<String, String> Params { get; set; }
    
    /// <summary>索引器，获取参数</summary>
    public String this[String name]
    {
        get => Params.TryGetValue(name, out var v) ? v : null;
        set => Params[name] = value;
    }
}
```

---

## 33.2 EntityModelBinder（实体绑定器）

### 功能概述

`EntityModelBinder` 用于绑定 XCode 实体对象，核心特点：

- 对于编辑操作，先从数据库查询实体再绑定
- 支持主键和联合主键查询
- 自动处理 JSON Body 数据
- 支持 IModel 接口

### 绑定器实现

```csharp
/// <summary>实体模型绑定器</summary>
class EntityModelBinder : IModelBinder
{
    private readonly IDictionary<ModelMetadata, IModelBinder> _propertyBinders;
    private Func<Object> _modelCreator;
    
    public async Task BindModelAsync(ModelBindingContext bindingContext)
    {
        // 创建或查询模型
        bindingContext.Model ??= CreateModel(bindingContext);
        
        // 绑定属性
        var modelMetadata = bindingContext.ModelMetadata;
        foreach (var property in modelMetadata.Properties)
        {
            if (!CanBindProperty(bindingContext, property)) continue;
            
            var name = property.BinderModelName ?? property.PropertyName;
            var modelName = ModelNames.CreatePropertyModelName(bindingContext.ModelName, name);
            await BindProperty(bindingContext, property, name, modelName);
        }
        
        bindingContext.Result = ModelBindingResult.Success(bindingContext.Model);
    }
    
    /// <summary>创建模型。对于有Key的请求，先查出来数据</summary>
    protected virtual Object CreateModel(ModelBindingContext bindingContext)
    {
        var modelType = bindingContext.ModelType;
        
        // 尝试从body读取json格式的参数
        var ctx = bindingContext.HttpContext;
        var request = ctx.Request;
        if (request.GetRequestBody<Object>() != null)
        {
            ctx.Items["EntityBody"] = ctx.Items["RequestBody"];
            var cubeBodyValueProvider = new CubeBodyValueProvider(
                bindingContext.ValueProvider,
                ctx.Items["EntityBody"] as NullableDictionary<String, Object>);
            bindingContext.ValueProvider = cubeBodyValueProvider;
        }
        
        // 非实体类型，使用默认创建
        if (!modelType.As<IEntity>()) return CreateModel2(bindingContext);
        
        var fact = EntityFactory.CreateFactory(modelType);
        if (fact == null) return CreateModel2(bindingContext);
        
        var pks = fact.Table.PrimaryKeys;
        var uk = fact.Unique;
        
        // 填充接口入参中的实体对象，Add新增除外
        IEntity entity = null;
        var act = bindingContext.ActionContext?.ActionDescriptor as ControllerActionDescriptor;
        
        if (act == null || !act.ActionName.EqualIgnoreCase("Add"))
        {
            if (uk != null)
            {
                // 按唯一键查询
                var id = bindingContext.ValueProvider.GetValue(uk.Name);
                if (id != ValueProviderResult.None)
                    entity = fact.FindByKeyForEdit(id.ToString());
            }
            else if (pks.Length > 0)
            {
                // 按联合主键查询
                var exp = new WhereExpression();
                foreach (var item in pks)
                {
                    var v = bindingContext.ValueProvider.GetValue(item.Name);
                    if (v == ValueProviderResult.None) continue;
                    exp &= item.Equal(v.ChangeType(item.Type));
                }
                entity = fact.Find(exp);
            }
        }
        
        return entity ?? fact.Create(true);
    }
}
```

### 绑定器提供者

```csharp
/// <summary>实体模型绑定器提供者</summary>
public class EntityModelBinderProvider : IModelBinderProvider
{
    public IModelBinder GetBinder(ModelBinderProviderContext context)
    {
        var modelType = context.Metadata.ModelType;
        
        // 只处理实体类型和 IModel 接口
        if (!modelType.As<IEntity>() && !modelType.As<IModel>())
            return null;
        
        var propertyBinders = new Dictionary<ModelMetadata, IModelBinder>();
        foreach (var property in context.Metadata.Properties)
        {
            propertyBinders.Add(property, context.CreateBinder(property));
        }
        
        return new EntityModelBinder(propertyBinders);
    }
}
```

### 使用示例

```csharp
// 编辑操作：自动从数据库查询实体
[HttpPost]
public ActionResult Edit(Student model)
{
    // model 已经是从数据库查询出来的实体
    // 只有提交的字段会被修改，其他字段保持原值
    
    if (!Valid(model, DataObjectMethodType.Update, true))
        throw new Exception("验证失败");
    
    model.Update();
    
    return RedirectToAction("Index");
}

// 添加操作：创建新实体
[HttpPost]
public ActionResult Add(Student model)
{
    // model 是新创建的实体
    
    model.Insert();
    
    return RedirectToAction("Index");
}
```

---

## 33.3 JsonModelBinder（JSON绑定器）

### 功能概述

`JsonModelBinder` 用于处理 JSON Body 请求，支持：

- 自动解析 JSON Body
- 绑定到 ICubeModel 接口
- 绑定到配置类 Config<T>

### 绑定器实现

```csharp
/// <summary>Json模型绑定器</summary>
public class JsonModelBinder : IModelBinder
{
    private readonly IDictionary<ModelMetadata, IModelBinder> _propertyBinders;
    private readonly ILoggerFactory _loggerFactory;
    
    public JsonModelBinder(IDictionary<ModelMetadata, IModelBinder> propertyBinders, ILoggerFactory loggerFactory)
    {
        _propertyBinders = propertyBinders ?? throw new ArgumentNullException(nameof(propertyBinders));
        _loggerFactory = loggerFactory ?? throw new ArgumentNullException(nameof(loggerFactory));
    }
    
    public async Task BindModelAsync(ModelBindingContext bindingContext)
    {
        var req = bindingContext.HttpContext.Request;
        var modelType = bindingContext.ModelType;
        
        // 尝试从 Body 读取 JSON 并反序列化
        var entityBody = req.GetRequestBody(modelType);
        
        if (entityBody != null)
        {
            bindingContext.Result = ModelBindingResult.Success(entityBody);
        }
        else
        {
            // 使用默认绑定器
            var modelBinder = new ComplexTypeModelBinder(_propertyBinders, _loggerFactory);
            await modelBinder.BindModelAsync(bindingContext);
        }
    }
}
```

### 绑定器提供者

```csharp
/// <summary>Json模型绑定器提供者</summary>
public class JsonModelBinderProvider : IModelBinderProvider
{
    public IModelBinder GetBinder(ModelBinderProviderContext context)
    {
        var modelType = context.Metadata.ModelType;
        
        // 检查是否是配置类
        var isGenericType = false;
        if (modelType.BaseType?.FullName?.StartsWith("NewLife.Configuration.Config`1[") == true)
        {
            var genericType = typeof(Config<>).MakeGenericType(modelType);
            isGenericType = modelType.As(genericType);
        }
        
        // 只处理 ICubeModel 接口和配置类
        if (modelType.As<ICubeModel>() || isGenericType)
        {
            var propertyBinders = new Dictionary<ModelMetadata, IModelBinder>();
            foreach (var property in context.Metadata.Properties)
            {
                propertyBinders.Add(property, context.CreateBinder(property));
            }
            
            var loggerFactory = context.Services.GetRequiredService<ILoggerFactory>();
            return new JsonModelBinder(propertyBinders, loggerFactory);
        }
        
        return null;
    }
}
```

### 使用示例

```csharp
// 实现 ICubeModel 接口
public class LoginModel : ICubeModel
{
    public String Username { get; set; }
    public String Password { get; set; }
    public Boolean Remember { get; set; }
}

// 控制器中使用
[HttpPost]
public ActionResult Login([FromBody] LoginModel model)
{
    // model 自动从 JSON Body 绑定
    // 请求：POST /login
    // Body: { "username": "admin", "password": "123456", "remember": true }
    
    var result = _userService.Login(model, HttpContext);
    return Json(result);
}
```

---

## 33.4 CubeBodyValueProvider

### 功能概述

`CubeBodyValueProvider` 是一个复合值提供者，支持从 Body 和其他来源获取值：

```csharp
/// <summary>魔方Body值提供者</summary>
public class CubeBodyValueProvider : IValueProvider
{
    private readonly IValueProvider _valueProvider;
    private readonly NullableDictionary<String, Object> _bodyValues;
    
    public CubeBodyValueProvider(IValueProvider valueProvider, NullableDictionary<String, Object> bodyValues)
    {
        _valueProvider = valueProvider;
        _bodyValues = bodyValues;
    }
    
    public Boolean ContainsPrefix(String prefix)
    {
        // 先检查 Body
        if (_bodyValues != null && _bodyValues.ContainsKey(prefix))
            return true;
        
        // 再检查其他来源
        return _valueProvider.ContainsPrefix(prefix);
    }
    
    public ValueProviderResult GetValue(String key)
    {
        // 先从 Body 获取
        if (_bodyValues != null && _bodyValues.TryGetValue(key, out var value))
        {
            if (value != null)
                return new ValueProviderResult(value.ToString());
        }
        
        // 再从其他来源获取
        return _valueProvider.GetValue(key);
    }
}
```

---

## 33.5 注册模型绑定器

### 在 AddCube 中自动注册

```csharp
services.Configure<MvcOptions>(options =>
{
    // JSON 模型绑定器
    options.ModelBinderProviders.Insert(0, new JsonModelBinderProvider());
    
    // 分页器绑定器
    options.ModelBinderProviders.Insert(0, new PagerModelBinderProvider());
    
    // 实体模型绑定器
    options.ModelBinderProviders.Insert(0, new EntityModelBinderProvider());
    
    // 验证深度
    options.MaxValidationDepth = 16;
    
    // 添加实体验证元数据提供者
    options.ModelMetadataDetailsProviders.Add(new EntityValidationMetadataProvider());
});
```

### 自定义注册

```csharp
// 在 Program.cs 中手动注册
builder.Services.Configure<MvcOptions>(options =>
{
    options.ModelBinderProviders.Insert(0, new MyCustomModelBinderProvider());
});
```

---

## 33.6 自定义模型绑定器

### 创建自定义绑定器

```csharp
/// <summary>日期范围绑定器</summary>
public class DateRangeModelBinder : IModelBinder
{
    public Task BindModelAsync(ModelBindingContext bindingContext)
    {
        var start = bindingContext.ValueProvider.GetValue("dtStart");
        var end = bindingContext.ValueProvider.GetValue("dtEnd");
        
        var model = new DateRange
        {
            Start = start.FirstValue.ToDateTime(),
            End = end.FirstValue.ToDateTime()
        };
        
        bindingContext.Result = ModelBindingResult.Success(model);
        return Task.CompletedTask;
    }
}

/// <summary>日期范围绑定器提供者</summary>
public class DateRangeModelBinderProvider : IModelBinderProvider
{
    public IModelBinder GetBinder(ModelBinderProviderContext context)
    {
        if (context.Metadata.ModelType == typeof(DateRange))
            return new DateRangeModelBinder();
        
        return null;
    }
}

/// <summary>日期范围模型</summary>
public class DateRange
{
    public DateTime Start { get; set; }
    public DateTime End { get; set; }
}
```

### 使用自定义绑定器

```csharp
// 注册
builder.Services.Configure<MvcOptions>(options =>
{
    options.ModelBinderProviders.Insert(0, new DateRangeModelBinderProvider());
});

// 使用
public ActionResult Report(DateRange range)
{
    // 请求：?dtStart=2024-01-01&dtEnd=2024-12-31
    // range.Start = 2024-01-01
    // range.End = 2024-12-31
    
    var data = GetReportData(range.Start, range.End);
    return View(data);
}
```

---

## 33.7 模型绑定最佳实践

### 1. 优先级顺序

模型绑定器按注册顺序执行，先注册的优先级高：

```csharp
// 顺序：JsonModelBinder → PagerModelBinder → EntityModelBinder → 默认绑定器
options.ModelBinderProviders.Insert(0, new JsonModelBinderProvider());
options.ModelBinderProviders.Insert(0, new PagerModelBinderProvider());
options.ModelBinderProviders.Insert(0, new EntityModelBinderProvider());
```

### 2. 数据来源优先级

```
Route > Query > Form > Body
```

### 3. 实体绑定注意事项

```csharp
// ? 正确：编辑时自动查询实体
[HttpPost]
public ActionResult Edit(Student model)
{
    // model 已经从数据库加载，只更新提交的字段
    model.Update();
    return Ok();
}

// ? 错误：直接创建新实体会丢失原有数据
[HttpPost]
public ActionResult Edit([FromBody] Student model)
{
    // 如果绑定器没有正确配置，model 可能是新实体
    // 更新时会丢失未提交的字段
}
```

### 4. 避免过度绑定

```csharp
// 使用 BindAttribute 限制绑定的属性
[HttpPost]
public ActionResult Update([Bind("Name,Email,Phone")] Student model)
{
    // 只绑定指定的属性，防止恶意提交
}

// 或使用 DTO
public class StudentUpdateDto
{
    public String Name { get; set; }
    public String Email { get; set; }
    public String Phone { get; set; }
}
```

---

## 本章小结

本章介绍了魔方的模型绑定机制：

1. **PagerModelBinder**：分页参数绑定
2. **EntityModelBinder**：实体对象绑定，支持编辑时先查询
3. **JsonModelBinder**：JSON Body 绑定
4. **CubeBodyValueProvider**：复合值提供者
5. **自定义绑定器**：扩展绑定逻辑

模型绑定是 MVC 框架的核心功能，魔方的自定义绑定器大大简化了实体操作的代码。

---

**下一章**：[自定义实体与模型](自定义实体与模型.md) - 了解如何自定义实体和模型
