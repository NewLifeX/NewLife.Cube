# 第31章 服务扩展

> 本章介绍魔方核心服务的扩展方式，包括 CubeService、UserService、TokenService 等服务的使用和自定义。

---

## 31.1 CubeService 核心服务

### 服务概述

`CubeService` 是魔方的核心服务配置类，负责初始化和配置魔方的所有功能。

### AddCube 方法

在 `Program.cs` 中添加魔方服务：

```csharp
var builder = WebApplication.CreateBuilder(args);

// 添加控制器和视图
builder.Services.AddControllersWithViews();

// 添加魔方
builder.Services.AddCube();

var app = builder.Build();

// 使用魔方
app.UseCube(app.Environment);

app.MapControllerRoute(
    name: "default",
    pattern: "{controller=Home}/{action=Index}/{id?}");

app.Run();
```

### AddCube 内部初始化

`AddCube` 方法执行以下初始化操作：

1. **身份验证配置**
   ```csharp
   services.AddAuthentication(options =>
   {
       options.DefaultScheme = "Cube";
       options.DefaultAuthenticateScheme = "Cube";
   }).AddCookie("Cube", options =>
   {
       options.LoginPath = "/Admin/User/Login";
       options.LogoutPath = "/Admin/User/Logout";
   });
   ```

2. **跨域配置**
   ```csharp
   // 配置 CORS
   if (set.CorsOrigins == "*")
       services.AddCors(options => options.AddPolicy("cube_cors", builder =>
           builder.AllowAnyMethod()
                  .AllowAnyHeader()
                  .AllowCredentials()
                  .SetIsOriginAllowed(hostname => true)));
   ```

3. **模型绑定器**
   ```csharp
   services.Configure<MvcOptions>(options =>
   {
       options.ModelBinderProviders.Insert(0, new JsonModelBinderProvider());
       options.ModelBinderProviders.Insert(0, new PagerModelBinderProvider());
       options.ModelBinderProviders.Insert(0, new EntityModelBinderProvider());
   });
   ```

4. **核心服务注册**
   ```csharp
   services.AddSingleton<UIService>();
   services.AddSingleton<PasswordService>();
   services.AddSingleton<UserService>();
   services.AddSingleton<AccessService>();
   services.AddSingleton<TokenService>();
   services.AddSingleton<SmsService>();
   services.AddSingleton<MailService>();
   ```

### UseCube 中间件

`UseCube` 方法配置中间件管道：

```csharp
public static IApplicationBuilder UseCube(this IApplicationBuilder app, IWebHostEnvironment env)
{
    // 使用 CORS
    app.UseCors("cube_cors");
    
    // 运行时间中间件
    app.UseMiddleware<RunTimeMiddleware>();
    
    // 异常处理
    if (env.IsDevelopment())
        app.UseDeveloperExceptionPage();
    else
        app.UseExceptionHandler("/Home/Error");
    
    // 静态文件
    app.UseStaticFiles();
    
    // 路由
    app.UseRouting();
    
    // 认证和授权
    app.UseAuthentication();
    app.UseAuthorization();
    
    return app;
}
```

---

## 31.2 UserService 用户服务

### 服务概述

`UserService` 提供用户相关的核心功能，包括登录、验证码发送等。

### 登录功能

```csharp
public class UserService
{
    private readonly ICache _cache;
    private readonly SmsService _smsService;
    private readonly MailService _mailService;
    
    /// <summary>登录</summary>
    /// <param name="loginModel">登录模型</param>
    /// <param name="httpContext">HTTP上下文</param>
    /// <returns>登录结果</returns>
    public LoginResult Login(LoginModel loginModel, HttpContext httpContext)
    {
        var username = loginModel.Username;
        var password = loginModel.Password;
        var ip = httpContext.GetUserHost();
        
        // 连续错误校验
        var key = $"CubeLogin:{username}";
        var errors = _cache.Get<Int32>(key);
        
        var set = CubeSetting.Current;
        if (errors >= set.MaxLoginError && set.MaxLoginError > 0)
            throw new InvalidOperationException($"登录错误过多，请稍后再试！");
        
        // 密码解密（如果使用RSA加密）
        if (!loginModel.Pkey.IsNullOrEmpty())
        {
            var pdic = _cache.Get<Tuple<String, String>>(loginModel.Pkey);
            password = Decrypt(pdic.Item2, password);
        }
        
        // 验证登录
        var provider = ManageProvider.Provider;
        if (provider.Login(username, password, loginModel.Remember) == null)
            return new LoginResult { Result = "用户名或密码错误" };
        
        // 登录成功，清空错误计数
        _cache.Remove(key);
        
        // 颁发令牌
        var tokens = httpContext.IssueTokenAndRefreshToken(
            provider.Current, 
            TimeSpan.FromSeconds(set.TokenExpire));
        
        return new LoginResult 
        { 
            AccessToken = tokens.Item1, 
            RefreshToken = tokens.Item2 
        };
    }
}
```

### 验证码功能

```csharp
/// <summary>发送登录验证码</summary>
public async Task<VerifyCodeRecord> SendVerifyCode(VerifyCodeModel model, String ip)
{
    var user = model.Username?.Trim() ?? "";
    if (user.IsNullOrEmpty()) throw new XException("账号不能为空");
    
    // 根据渠道或格式判断发送方式
    if (model.Channel.EqualIgnoreCase("Mail") || user.Contains('@'))
        return await SendMailCode(model, ip);
    
    if (model.Channel.EqualIgnoreCase("Sms") || SmsService.IsValidPhone(user))
        return await SendSmsCode(model, ip);
    
    throw new NotSupportedException("不支持的验证码发送方式");
}
```

### 使用 UserService

```csharp
public class AccountController : Controller
{
    private readonly UserService _userService;
    
    public AccountController(UserService userService)
    {
        _userService = userService;
    }
    
    [HttpPost]
    public ActionResult Login([FromBody] LoginModel model)
    {
        var result = _userService.Login(model, HttpContext);
        return Json(result);
    }
    
    [HttpPost]
    public async Task<ActionResult> SendCode([FromBody] VerifyCodeModel model)
    {
        var ip = HttpContext.GetUserHost();
        var record = await _userService.SendVerifyCode(model, ip);
        return Json(new { success = true, expireTime = record.ExpireTime });
    }
}
```

---

## 31.3 TokenService 令牌服务

### 服务概述

`TokenService` 提供应用令牌的颁发和验证功能，用于 API 认证。

### 核心方法

```csharp
public class TokenService
{
    /// <summary>根据名称查找应用</summary>
    public App FindByName(String name) => App.FindByName(name);
    
    /// <summary>根据密钥查找应用</summary>
    public App FindBySecret(String appKey) => App.FindBySecret(appKey);
    
    /// <summary>验证应用密码，不存在时新增</summary>
    /// <param name="username">应用名</param>
    /// <param name="password">密码</param>
    /// <param name="autoRegister">自动注册</param>
    /// <param name="ip">客户端IP</param>
    /// <returns></returns>
    public App Authorize(String username, String password, Boolean autoRegister, String ip = null)
    {
        if (username.IsNullOrEmpty()) 
            throw new ArgumentNullException(nameof(username));
        
        // 查找或创建应用
        var app = FindByName(username);
        app ??= App.GetOrAdd(username, App.FindByName, k => new App
        {
            Name = username,
            Secret = password,
            Enable = autoRegister,
        });
        
        // 检查黑白名单
        if (!app.ValidSource(ip))
            throw new ApiException(403, $"应用[{username}]禁止{ip}访问！");
        
        // 检查应用有效性
        if (!app.Enable) 
            throw new ApiException(403, $"应用[{username}]已禁用！");
        if (!app.Secret.IsNullOrEmpty() && password != app.Secret) 
            throw new ApiException(401, $"非法访问应用[{username}]！");
        
        return app;
    }
    
    /// <summary>颁发令牌</summary>
    /// <param name="name">应用名</param>
    /// <param name="secret">密钥（格式：算法:密钥）</param>
    /// <param name="expire">有效期（秒）</param>
    /// <param name="id">令牌标识</param>
    /// <returns></returns>
    public TokenModel IssueToken(String name, String secret, Int32 expire, String id = null)
    {
        if (id.IsNullOrEmpty()) id = Rand.NextString(8);
        
        var ss = secret.Split(':');
        var jwt = new JwtBuilder
        {
            Issuer = Assembly.GetEntryAssembly().GetName().Name,
            Subject = name,
            Id = id,
            Expire = DateTime.Now.AddSeconds(expire),
            Algorithm = ss[0],
            Secret = ss[1],
        };
        
        return new TokenModel
        {
            AccessToken = jwt.Encode(null),
            TokenType = jwt.Type ?? "JWT",
            ExpireIn = expire,
            RefreshToken = jwt.Encode(null),
        };
    }
    
    /// <summary>解码令牌</summary>
    public (JwtBuilder, App) DecodeToken(String token, String tokenSecret)
    {
        if (token.IsNullOrEmpty()) 
            throw new ArgumentNullException(nameof(token));
        
        var ss = tokenSecret.Split(':');
        var jwt = new JwtBuilder
        {
            Algorithm = ss[0],
            Secret = ss[1],
        };
        
        if (!jwt.TryDecode(token, out var message))
            throw new ApiException(403, $"非法访问 {message}");
        
        var app = FindByName(jwt.Subject);
        return (jwt, app);
    }
}
```

### 使用示例

```csharp
public class ApiController : Controller
{
    private readonly TokenService _tokenService;
    
    public ApiController(TokenService tokenService)
    {
        _tokenService = tokenService;
    }
    
    /// <summary>获取访问令牌</summary>
    [HttpPost]
    public ActionResult Token(String appId, String secret)
    {
        var app = _tokenService.Authorize(appId, secret, false, HttpContext.GetUserHost());
        
        var tokenSecret = $"HS256:{app.Secret}";
        var token = _tokenService.IssueToken(app.Name, tokenSecret, 7200);
        
        return Json(token);
    }
}
```

---

## 31.4 PasswordService 密码服务

### 服务概述

`PasswordService` 提供密码强度验证功能。

### 密码强度验证

```csharp
public class PasswordService
{
    private Regex _regex;
    private String _old;
    
    /// <summary>验证密码强度</summary>
    /// <param name="password">密码</param>
    /// <returns>是否满足强度要求</returns>
    public Boolean Valid(String password)
    {
        if (password == null) 
            throw new ArgumentNullException(nameof(password));
        
        // 没有设置密码强度，直接通过
        var set = CubeSetting.Current;
        if (set.PaswordStrength.IsNullOrEmpty() || set.PaswordStrength == "*") 
            return true;
        
        // 缓存正则表达式
        if (_regex == null || set.PaswordStrength != _old)
        {
            _regex = new Regex(set.PaswordStrength, RegexOptions.Compiled);
            _old = set.PaswordStrength;
        }
        
        return _regex.IsMatch(password);
    }
}
```

### 密码强度配置

在 `CubeSetting` 中配置密码强度正则表达式：

```json
{
  "CubeSetting": {
    "PaswordStrength": "^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)[a-zA-Z\\d]{8,}$"
  }
}
```

常用密码强度规则：

| 规则 | 正则表达式 | 说明 |
|------|-----------|------|
| 无限制 | `*` | 任意密码 |
| 最少8位 | `.{8,}` | 至少8个字符 |
| 字母+数字 | `^(?=.*[a-zA-Z])(?=.*\d).{8,}$` | 至少包含字母和数字 |
| 大小写+数字 | `^(?=.*[a-z])(?=.*[A-Z])(?=.*\d).{8,}$` | 包含大小写字母和数字 |
| 强密码 | `^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&]).{8,}$` | 包含特殊字符 |

### 使用示例

```csharp
public class UserController : Controller
{
    private readonly PasswordService _passwordService;
    
    public UserController(PasswordService passwordService)
    {
        _passwordService = passwordService;
    }
    
    [HttpPost]
    public ActionResult ChangePassword(String oldPassword, String newPassword)
    {
        // 验证密码强度
        if (!_passwordService.Valid(newPassword))
            return Json(new { success = false, message = "密码强度不足" });
        
        // 修改密码逻辑...
        
        return Json(new { success = true });
    }
}
```

---

## 31.5 JobService 作业服务

### 服务概述

`JobService` 是魔方的定时作业调度服务，管理所有 `CronJob` 定时任务。

### 启用定时作业

```csharp
// 在 AddCube 中已自动注册
services.AddCubeJob();
```

### 作业服务实现

```csharp
public class JobService : IHostedService
{
    private static readonly IList<MyJob> _jobs = [];
    private readonly IServiceProvider _serviceProvider;
    private static TimerX _timer;
    
    public Task StartAsync(CancellationToken cancellationToken)
    {
        // 定时检测作业参数的变更
        _timer = new TimerX(DoJob, null, 1_000, 600_000) { Async = true };
        return Task.CompletedTask;
    }
    
    public Task StopAsync(CancellationToken cancellationToken)
    {
        _timer.TryDispose();
        _jobs.ToArray().TryDispose();
        _jobs.Clear();
        return Task.CompletedTask;
    }
    
    /// <summary>唤醒作业调度</summary>
    public static void Wake() => _timer.SetNext(1_000);
    
    /// <summary>唤醒具体作业</summary>
    public static void Wake(Int32 jobId, Int32 ms)
    {
        var job = _jobs.FirstOrDefault(e => e.Job.Id == jobId);
        job?.Wake(ms);
    }
}
```

### 扫描并注册作业

```csharp
/// <summary>扫描并添加ICubeJob作业</summary>
public static void ScanJobs()
{
    var jobs = CronJob.FindAll();
    
    foreach (var type in typeof(ICubeJob).GetAllSubclasses())
    {
        var name = type.Name;
        var att = type.GetCustomAttribute<CronJobAttribute>();
        if (att != null) name = att.Name;
        
        // 查找或新增作业
        var job = jobs.FirstOrDefault(e => e.Name.EqualIgnoreCase(name));
        job ??= new CronJob
        {
            Name = name,
            Cron = att?.Cron,
            Enable = att?.Enable ?? true,
            EnableLog = true,
            Remark = type.GetDescription(),
        };
        
        job.DisplayName = type.GetDisplayName();
        job.Method = type.FullName;
        job.Save();
    }
}
```

---

## 31.6 AccessService 访问服务

### 服务概述

`AccessService` 提供访问规则验证功能，实现 IP 白名单/黑名单、限流等安全控制。

### 核心方法

```csharp
public class AccessService
{
    private readonly ICacheProvider _cacheProvider;
    
    /// <summary>验证是否允许当前请求访问</summary>
    /// <param name="url">请求URL</param>
    /// <param name="ua">用户代理</param>
    /// <param name="ip">客户端IP</param>
    /// <param name="user">当前用户</param>
    /// <param name="session">会话</param>
    /// <returns>匹配的阻止规则，null表示允许访问</returns>
    public AccessRule Valid(String url, UserAgentParser ua, String ip, IUser user, IDictionary<String, Object> session)
    {
        var rules = AccessRule.FindAllWithCache()
            .Where(e => e.Enable)
            .OrderByDescending(e => e.Priority)
            .ToList();
        
        if (rules.Count == 0) return null;
        
        foreach (var rule in rules)
        {
            if (IsMatch(rule, url, ua.UserAgent, ip, user))
            {
                switch (rule.ActionKind)
                {
                    case AccessActionKinds.Pass:
                        return null;  // 放行
                    
                    case AccessActionKinds.Block:
                        return rule;  // 阻止
                    
                    case AccessActionKinds.Limit:
                        // 验证限流
                        if (!ValidLimit(rule, url, ua.UserAgent, ip, user, session))
                            return rule;
                        return null;
                }
            }
        }
        
        return null;
    }
    
    /// <summary>验证限流</summary>
    private Boolean ValidLimit(AccessRule rule, String url, String userAgent, String ip, IUser user, IDictionary<String, Object> session)
    {
        if (rule.LimitCycle <= 0 || rule.LimitTimes <= 0) return true;
        
        // 确定限流维度（IP或用户）
        var key = rule.LimitDimension switch
        {
            LimitDimensions.User => user?.Name,
            _ => ip,
        };
        if (key.IsNullOrEmpty()) return true;
        
        // 计算时间窗口
        var now = DateTime.Now;
        var sec = (Int32)(now - now.Date).TotalSeconds;
        var time = sec / rule.LimitCycle;
        
        // 限流缓存键
        var cacheKey = $"access:{rule.Id}:{key}:{time}";
        
        // 递增并设置过期时间
        var hits = _cacheProvider.Cache.Increment(cacheKey, 1);
        if (hits <= 2)
            _cacheProvider.Cache.SetExpire(cacheKey, TimeSpan.FromSeconds(rule.LimitCycle));
        
        return hits <= rule.LimitTimes;
    }
}
```

### 使用示例

```csharp
public class SecurityMiddleware
{
    private readonly RequestDelegate _next;
    private readonly AccessService _accessService;
    
    public SecurityMiddleware(RequestDelegate next, AccessService accessService)
    {
        _next = next;
        _accessService = accessService;
    }
    
    public async Task InvokeAsync(HttpContext context)
    {
        var url = context.Request.Path;
        var ip = context.GetUserHost();
        var ua = new UserAgentParser(context.Request.Headers["User-Agent"]);
        var user = ManageProvider.User;
        
        var rule = _accessService.Valid(url, ua, ip, user, context.Session);
        if (rule != null)
        {
            context.Response.StatusCode = 403;
            await context.Response.WriteAsync($"访问被拒绝：{rule.Name}");
            return;
        }
        
        await _next(context);
    }
}
```

---

## 31.7 FileStorageService 文件存储服务

### 服务概述

`FileStorageService` 提供分布式文件存储功能，支持多节点文件同步。

### 注册服务

```csharp
// 在 AddCube 中已自动注册
services.AddCubeFileStorage();

// 或自定义集群名
services.AddCubeFileStorage("MyCluster");
```

### CubeFileStorage 实现

```csharp
public class CubeFileStorage : DefaultFileStorage
{
    public CubeFileStorage(CubeSetting setting, IServiceProvider serviceProvider, 
        ICacheProvider cacheProvider, ITracer tracer, ILog log)
    {
        RootPath = setting.UploadPath;
        DownloadUri = "/cube/file?id={Id}";
        
        ServiceProvider = serviceProvider;
        Tracer = tracer;
        Log = log;
    }
    
    /// <summary>初始化</summary>
    protected override Task OnInitializedAsync(CancellationToken cancellationToken)
    {
        // 优先Redis队列作为事件总线
        var cache = _cacheProvider.Cache;
        if (cache.GetType() != typeof(MemoryCache))
            SetEventBus(_cacheProvider);
        else if (_registry is AppClient client)
            SetEventBus(client);
        
        return base.OnInitializedAsync(cancellationToken);
    }
    
    /// <summary>获取本地文件的元数据</summary>
    protected override IFileInfo GetLocalFileMeta(Int64 attachmentId, String path)
    {
        var att = Attachment.FindById(attachmentId);
        return new NewFileInfo
        {
            Id = att.Id,
            Name = att.FileName,
            Path = att.FilePath,
            Hash = att.Hash,
            Length = att.Size,
        };
    }
}
```

### 使用文件存储

```csharp
public class FileController : Controller
{
    private readonly IFileStorage _fileStorage;
    
    public FileController(IFileStorage fileStorage)
    {
        _fileStorage = fileStorage;
    }
    
    /// <summary>上传文件</summary>
    [HttpPost]
    public async Task<ActionResult> Upload(IFormFile file)
    {
        using var stream = file.OpenReadStream();
        var fileInfo = await _fileStorage.SaveAsync(stream, file.FileName);
        
        return Json(new { id = fileInfo.Id, url = fileInfo.DownloadUrl });
    }
    
    /// <summary>下载文件</summary>
    [HttpGet]
    public async Task<ActionResult> Download(Int64 id)
    {
        var stream = await _fileStorage.GetAsync(id);
        if (stream == null) return NotFound();
        
        var fileInfo = await _fileStorage.GetInfoAsync(id);
        return File(stream, "application/octet-stream", fileInfo.Name);
    }
}
```

---

## 31.8 自定义服务扩展

### 创建自定义服务

```csharp
/// <summary>自定义业务服务</summary>
public class MyBusinessService
{
    private readonly ILogger<MyBusinessService> _logger;
    private readonly ITracer _tracer;
    
    public MyBusinessService(ILogger<MyBusinessService> logger, ITracer tracer)
    {
        _logger = logger;
        _tracer = tracer;
    }
    
    public async Task<Result> ProcessAsync(MyRequest request)
    {
        using var span = _tracer?.NewSpan(nameof(ProcessAsync), request);
        
        try
        {
            // 业务逻辑
            _logger.LogInformation("处理请求：{Request}", request.Id);
            
            return new Result { Success = true };
        }
        catch (Exception ex)
        {
            span?.SetError(ex, null);
            _logger.LogError(ex, "处理失败");
            throw;
        }
    }
}
```

### 注册自定义服务

```csharp
// 在 Program.cs 中注册
builder.Services.AddSingleton<MyBusinessService>();

// 或使用 Scoped 生命周期
builder.Services.AddScoped<MyBusinessService>();
```

### 在控制器中使用

```csharp
public class MyController : EntityController<MyEntity>
{
    private readonly MyBusinessService _businessService;
    
    public MyController(MyBusinessService businessService)
    {
        _businessService = businessService;
    }
    
    [HttpPost]
    public async Task<ActionResult> Process([FromBody] MyRequest request)
    {
        var result = await _businessService.ProcessAsync(request);
        return Json(result);
    }
}
```

---

## 本章小结

本章介绍了魔方的核心服务扩展：

1. **CubeService**：魔方配置入口，初始化所有功能
2. **UserService**：用户登录、验证码等功能
3. **TokenService**：应用令牌的颁发和验证
4. **PasswordService**：密码强度验证
5. **JobService**：定时作业调度
6. **AccessService**：访问规则验证和限流
7. **FileStorageService**：分布式文件存储

掌握这些服务的使用和扩展方式，可以灵活定制魔方的核心功能。

---

**下一章**：[中间件与过滤器](中间件与过滤器.md) - 了解魔方的中间件和过滤器机制
